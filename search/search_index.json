{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"api/","text":"API server Generic library for building a LoxiLB API server. Usage \ud604\uc7ac API \uc11c\ubc84\ub294 HTTP, HTTPS\ubaa8\ub450 \uc9c0\uc6d0\ud558\uba70, Loxilb \uc2e4\ud589\uc2dc -a \ud639\uc740 --api \uc635\uc158\uc744 \ucd94\uac00\ud574\uc11c \uc2e4\ud589\uc774 \uac00\ub2a5\ud558\ub2e4. API\uc5d0 \uc0ac\uc6a9\ub418\ub294 \uc635\uc158\uc740 \ub2e4\uc74c\uacfc \uac19\ub2e4. \ubcf4\uc548\uc744 \uc704\ud574 HTTPS \uc635\uc158 --tls-key, --tls-certificate\ub97c \ubaa8\ub450 \uc8fc\uc5b4\uc57c\ub9cc \uc2e4\ud589\uc774 \uac00\ub2a5\ud558\ub2e4. Currently, the API server supports both HTTP and HTTPS, and can be run by adding -a or --api options when running Loxilb. The options used in the API are as follows. For security purposes, HTTPS options --tls-key, --tls-certificate must be given to run. --host= the IP to listen on (default: localhost) [$HOST] --port= the port to listen on for insecure connections, defaults to a random value [$PORT] --tls-host= the IP to listen on for tls, when not specified it's the same as --host [$TLS_HOST] --tls-port= the port to listen on for secure connections, defaults to a random value [$TLS_PORT] --tls-certificate= the certificate to use for secure connections [$TLS_CERTIFICATE] --tls-key= the private key to use for secure connections [$TLS_PRIVATE_KEY] \uc2e4\uc81c \uc0ac\uc6a9\ud558\ub294 \uc608\uc2dc\ub294 \ub2e4\uc74c\uacfc \uac19\ub2e4. Examples of practical use are as follows. ./loxilb --tls-key=api/certification/server.key --tls-certificate=api/certification/server.crt --host=0.0.0.0 --port=8081 --tls-port=8091 -a API list \ud604\uc7ac API\ub294 Load balancer \uc5d0 \ub300\ud55c Create, Delete, Read API\uac00 \uc788\ub2e4. Currently, the API has Create, Delete, and Read APIs for Load balancer. Method URL Role GET /netlox/v1/config/loadbalancer/all Get the load balancer information POST /netlox/v1/config/loadbalancer Add the load balancer information to LoxiLB DELETE /netlox/v1/config/loadbalancer/externalipaddress/{IPaddress}/port/{#Port}/protocol/{protocol} Delete the load balacer infomation from LoxiLB \ub354 \uc790\uc138\ud55c \uc815\ubcf4( Param, Body \ub4f1)\uc740 Swagger\ubb38\uc11c\ub97c \ucc38\uc870\ud55c\ub2e4. See Swagger documentation for more information (Param, Body, etc.). LoxiLB API development guide API source Architecture . \u251c\u2500\u2500 certification \u2502 \u251c\u2500\u2500 serverca.crt \u2502 \u2514\u2500\u2500 serverkey.pem \u251c\u2500\u2500 cmd \u2502 \u2514\u2500\u2500 loxilb_rest_api-server \u2502 \u2514\u2500\u2500 main.go \u251c\u2500\u2500 \u2026. \u251c\u2500\u2500 models \u2502 \u251c\u2500\u2500 error.go \u2502 \u251c\u2500\u2500 \u2026.. \u251c\u2500\u2500 restapi \u2502 \u251c\u2500\u2500 configure_loxilb_rest_api.go \u2502 \u251c\u2500\u2500 \u2026.. \u2502 \u251c\u2500\u2500 handler \u2502 \u2502 \u251c\u2500\u2500 common.go \u2502 \u2502 \u2514\u2500\u2500\u2026.. \u2502 \u251c\u2500\u2500 operations \u2502 \u2502 \u251c\u2500\u2500 get_config_conntrack_all.go \u2502 \u2502 \u2514\u2500\u2500 \u2026. \u2502 \u2514\u2500\u2500 server.go \u2514\u2500\u2500 swagger.yml Except for the ./api/restapi/handler and ./api/certification directories, the rest of the contents are automatically created. Add the logic for the function to the handler directory. Add logic to file ./api/restapi/configure_loxilb_rest_api.go Swagger.yml file update paths: '/additional/url/{param}': get: summary: Test Swagger API Server. description: Check Swagger API server. This basic information or architecture is for the later applications. parameters: - name: param in: path required: true type: string format: string description: Description of the additional url responses: '204': description: OK '400': description: Malformed arguments for API call schema: $ref: '#/definitions/Error' '401': description: Invalid authentication credentials path.{Set path and parameter URL}.{get,post,etc RESTful setting}.{Description} {Set path and parameter URL} Set the path used in the RESTful API. It begins with \"config/\" and is defined as a sub-category from a large category. Define the parameters using the symbol {param}. The parameters are defined in the description section. {get,post,etc RESTful setting} Use get, post, delete, and patch to define queries, registrations, deletions, and modifications. {Description} Summary description of API Detailed description of API Parameters Set the name, path, etc. Define the content of the response Creating Additional Parts with Swagger # alias swagger='docker run --rm -it --user $(id -u):$(id -g) -e GOPATH=$(go env GOPATH):/go -v $HOME:$HOME -w $(pwd) quay.io/goswagger/swagger' # swagger generate server Development of Additional Partial Handlers package handler import ( \"fmt\" \"github.com/go-openapi/runtime/middleware\" \"testswagger.com/restapi/operations\" ) func ConfigAdditionalUrl(params operations.GetAdditionalUrlParams) middleware.Responder { ///////////////////////////////////////////// // Add logic Here // ////////////////////////////////////////////. return &ResultResponse{Result: fmt.Sprintf(\"params.param : %s\", params.param)} } Select the logic required for the ConfigAdditionalUrl portion of the handler directory. The required parameters come from operations.GetAdditionalUrlParams. Additional Partial Handler Registration func configureAPI(api *operations.LoxilbRestAPIAPI) http.Handler { ...... // Change it by putting a function here api.GetAdditionalUrlHandler = operations.GetAdditionalUrlHandlerFunc(handler.ConfigAdditionalUrl) \u2026. } if api.{REST}...The Handler form is automatically generated, where if nil is erased and a handler is added to the operation function. In many cases, additional generation is not possible. In that case, you can add the function by entering it separately. The name of the function consists of a combination of Method, URL, and Parameter.","title":"Api usage/dev guide"},{"location":"api/#api-server","text":"Generic library for building a LoxiLB API server.","title":"API server"},{"location":"api/#usage","text":"\ud604\uc7ac API \uc11c\ubc84\ub294 HTTP, HTTPS\ubaa8\ub450 \uc9c0\uc6d0\ud558\uba70, Loxilb \uc2e4\ud589\uc2dc -a \ud639\uc740 --api \uc635\uc158\uc744 \ucd94\uac00\ud574\uc11c \uc2e4\ud589\uc774 \uac00\ub2a5\ud558\ub2e4. API\uc5d0 \uc0ac\uc6a9\ub418\ub294 \uc635\uc158\uc740 \ub2e4\uc74c\uacfc \uac19\ub2e4. \ubcf4\uc548\uc744 \uc704\ud574 HTTPS \uc635\uc158 --tls-key, --tls-certificate\ub97c \ubaa8\ub450 \uc8fc\uc5b4\uc57c\ub9cc \uc2e4\ud589\uc774 \uac00\ub2a5\ud558\ub2e4. Currently, the API server supports both HTTP and HTTPS, and can be run by adding -a or --api options when running Loxilb. The options used in the API are as follows. For security purposes, HTTPS options --tls-key, --tls-certificate must be given to run. --host= the IP to listen on (default: localhost) [$HOST] --port= the port to listen on for insecure connections, defaults to a random value [$PORT] --tls-host= the IP to listen on for tls, when not specified it's the same as --host [$TLS_HOST] --tls-port= the port to listen on for secure connections, defaults to a random value [$TLS_PORT] --tls-certificate= the certificate to use for secure connections [$TLS_CERTIFICATE] --tls-key= the private key to use for secure connections [$TLS_PRIVATE_KEY] \uc2e4\uc81c \uc0ac\uc6a9\ud558\ub294 \uc608\uc2dc\ub294 \ub2e4\uc74c\uacfc \uac19\ub2e4. Examples of practical use are as follows. ./loxilb --tls-key=api/certification/server.key --tls-certificate=api/certification/server.crt --host=0.0.0.0 --port=8081 --tls-port=8091 -a","title":"Usage"},{"location":"api/#api-list","text":"\ud604\uc7ac API\ub294 Load balancer \uc5d0 \ub300\ud55c Create, Delete, Read API\uac00 \uc788\ub2e4. Currently, the API has Create, Delete, and Read APIs for Load balancer. Method URL Role GET /netlox/v1/config/loadbalancer/all Get the load balancer information POST /netlox/v1/config/loadbalancer Add the load balancer information to LoxiLB DELETE /netlox/v1/config/loadbalancer/externalipaddress/{IPaddress}/port/{#Port}/protocol/{protocol} Delete the load balacer infomation from LoxiLB \ub354 \uc790\uc138\ud55c \uc815\ubcf4( Param, Body \ub4f1)\uc740 Swagger\ubb38\uc11c\ub97c \ucc38\uc870\ud55c\ub2e4. See Swagger documentation for more information (Param, Body, etc.).","title":"API list"},{"location":"api/#loxilb-api-development-guide","text":"","title":"LoxiLB API development guide"},{"location":"api/#api-source-architecture","text":". \u251c\u2500\u2500 certification \u2502 \u251c\u2500\u2500 serverca.crt \u2502 \u2514\u2500\u2500 serverkey.pem \u251c\u2500\u2500 cmd \u2502 \u2514\u2500\u2500 loxilb_rest_api-server \u2502 \u2514\u2500\u2500 main.go \u251c\u2500\u2500 \u2026. \u251c\u2500\u2500 models \u2502 \u251c\u2500\u2500 error.go \u2502 \u251c\u2500\u2500 \u2026.. \u251c\u2500\u2500 restapi \u2502 \u251c\u2500\u2500 configure_loxilb_rest_api.go \u2502 \u251c\u2500\u2500 \u2026.. \u2502 \u251c\u2500\u2500 handler \u2502 \u2502 \u251c\u2500\u2500 common.go \u2502 \u2502 \u2514\u2500\u2500\u2026.. \u2502 \u251c\u2500\u2500 operations \u2502 \u2502 \u251c\u2500\u2500 get_config_conntrack_all.go \u2502 \u2502 \u2514\u2500\u2500 \u2026. \u2502 \u2514\u2500\u2500 server.go \u2514\u2500\u2500 swagger.yml Except for the ./api/restapi/handler and ./api/certification directories, the rest of the contents are automatically created. Add the logic for the function to the handler directory. Add logic to file ./api/restapi/configure_loxilb_rest_api.go Swagger.yml file update paths: '/additional/url/{param}': get: summary: Test Swagger API Server. description: Check Swagger API server. This basic information or architecture is for the later applications. parameters: - name: param in: path required: true type: string format: string description: Description of the additional url responses: '204': description: OK '400': description: Malformed arguments for API call schema: $ref: '#/definitions/Error' '401': description: Invalid authentication credentials path.{Set path and parameter URL}.{get,post,etc RESTful setting}.{Description} {Set path and parameter URL} Set the path used in the RESTful API. It begins with \"config/\" and is defined as a sub-category from a large category. Define the parameters using the symbol {param}. The parameters are defined in the description section. {get,post,etc RESTful setting} Use get, post, delete, and patch to define queries, registrations, deletions, and modifications. {Description} Summary description of API Detailed description of API Parameters Set the name, path, etc. Define the content of the response Creating Additional Parts with Swagger # alias swagger='docker run --rm -it --user $(id -u):$(id -g) -e GOPATH=$(go env GOPATH):/go -v $HOME:$HOME -w $(pwd) quay.io/goswagger/swagger' # swagger generate server Development of Additional Partial Handlers package handler import ( \"fmt\" \"github.com/go-openapi/runtime/middleware\" \"testswagger.com/restapi/operations\" ) func ConfigAdditionalUrl(params operations.GetAdditionalUrlParams) middleware.Responder { ///////////////////////////////////////////// // Add logic Here // ////////////////////////////////////////////. return &ResultResponse{Result: fmt.Sprintf(\"params.param : %s\", params.param)} } Select the logic required for the ConfigAdditionalUrl portion of the handler directory. The required parameters come from operations.GetAdditionalUrlParams. Additional Partial Handler Registration func configureAPI(api *operations.LoxilbRestAPIAPI) http.Handler { ...... // Change it by putting a function here api.GetAdditionalUrlHandler = operations.GetAdditionalUrlHandlerFunc(handler.ConfigAdditionalUrl) \u2026. } if api.{REST}...The Handler form is automatically generated, where if nil is erased and a handler is added to the operation function. In many cases, additional generation is not possible. In that case, you can add the function by entering it separately. The name of the function consists of a combination of Method, URL, and Parameter.","title":"API source Architecture"},{"location":"arch/","text":"loxilb architecture and modules loxilb consists of the following modules : - loxilb CCM plugin It fully implements K8s CCM load-balancer interface and talks to goLang based loxilb process using Restful APIs. Although loxilb CCM is logically shown as part of loxilb cluster nodes, it will usually run in one of the worker/master nodes of the K8s cluster. loxicmd loxicmd is command line tool to configure and dump loxilb information which is based on same foundation as the wildly popular kubectl tools loxilb loxilb is a modern goLang based framework (process) which mantains information coming in from various sources e.g apiserver and populates the eBPF maps used by the loxilb eBPF kernel. It is also responsible for loading eBPF programs to the interfaces.It also acts as a client to goBGP to exchange routes based on information from loxilb CCM. Last but not the least, it will be finally responsible for maintaining HA state sync with its remote peers. Almost all serious lb implementations need to be deployed as a HA cluster. loxilb eBPF kernel eBPF kernel module implements the data-plane of loxilb which provides complete kernel bypass. It is a fully self contained and feature-rich stack able to process packets from rx to tx without invoking linux native kernel networking. goBGP Although goBGP is a separate project, loxilb has adopted and integrated with goBGP as its routing stack of choice. We also hope to develop features for this awesome project in the future. DashBoards Grafana based dashboards to provide highly dynamic insight into loxilb state. The following is a typical loxilb deployment topology (Currently HA implementation is in development) :","title":"Architecture in brief"},{"location":"arch/#loxilb-architecture-and-modules","text":"loxilb consists of the following modules : - loxilb CCM plugin It fully implements K8s CCM load-balancer interface and talks to goLang based loxilb process using Restful APIs. Although loxilb CCM is logically shown as part of loxilb cluster nodes, it will usually run in one of the worker/master nodes of the K8s cluster. loxicmd loxicmd is command line tool to configure and dump loxilb information which is based on same foundation as the wildly popular kubectl tools loxilb loxilb is a modern goLang based framework (process) which mantains information coming in from various sources e.g apiserver and populates the eBPF maps used by the loxilb eBPF kernel. It is also responsible for loading eBPF programs to the interfaces.It also acts as a client to goBGP to exchange routes based on information from loxilb CCM. Last but not the least, it will be finally responsible for maintaining HA state sync with its remote peers. Almost all serious lb implementations need to be deployed as a HA cluster. loxilb eBPF kernel eBPF kernel module implements the data-plane of loxilb which provides complete kernel bypass. It is a fully self contained and feature-rich stack able to process packets from rx to tx without invoking linux native kernel networking. goBGP Although goBGP is a separate project, loxilb has adopted and integrated with goBGP as its routing stack of choice. We also hope to develop features for this awesome project in the future. DashBoards Grafana based dashboards to provide highly dynamic insight into loxilb state. The following is a typical loxilb deployment topology (Currently HA implementation is in development) :","title":"loxilb architecture and modules"},{"location":"ccm/","text":"Howto - ccm plugin loxi-ccm is a cloud-manager that provides kubernetes with loxilb load balancer. kubernetes provides the cloud-provider interface for the implementation of external cloud provider-specific logic, and loxi-ccm is an implementation of the cloud-provider interface. Typical loxi-ccm deployment topology As seen in the loxilb architecture documentation , loxi-ccm is logically shown as part of the loxilb cluster. But it's actually running on the k8s master/control-plane node. loxi-ccm implements the k8s load balancer service function using RESTful API of loxilb. When a user creates a k8s load balancer type service, loxi-ccm allocates an IP from the registered External IP subnet Pool. loxi-ccm sets rules in loxilb to allow service access from external with the assigned IP. In other words, loxi-ccm needs two information. loxilb API server address External IP Subnet These informations are managed through k8s ConfigMap. loxi-ccm users should modify this informations to suit your environment. Deploy loxi-ccm on kubernetes The guide below has been tested in environment on Ubuntu 20.04, kubernetes v1.24 (calico CNI) 1. Modify k8s ConfigMap In the manifests/loxi-ccm.yaml manifests file, the ConfigMap is defined as follows --- apiVersion: v1 kind: ConfigMap metadata: name: loxilb-config namespace: kube-system data: apiServerURL: \"http://192.168.20.54:11111\" externalIPcidr: 123.123.123.0/24 --- The ConfigMap has two values: apiServerURL and externalIPcidr. apiServerURL : API Server address of loxilb. externalIPcidr : Subnet band to be allocated by loxilb as External IP of the load balancer. apiServerURL and externalIPcidr must be modified according to the environment of the user using loxi-ccm. 2. Deploy loxi-ccm Once you have modified ConfigMap, you can deploy loxi-ccm using the loxi-ccm.yaml manifest file. Run the following command on the kubernetes you want to deploy. kubectl apply -f loxi-ccm.yaml After entering the command, check whether loxi-cloud-controller-manager is created in the daemonset of the kube-system namespace. Manual build If you want to build loxi-ccm manually, do the following: 1. build ./build.sh 2. Build & upload container image Below is an example. This case use docker to build container images, and images is uploaded to docker hub. TAG=\"0.1\" DOCKER_ID=YOUR_DOCKER_ID sudo docker build -t $DOCKER_ID/loxi-ccm:$TAG -f ./Dockerfile . sudo docker push $DOCKER_ID/loxi-ccm:$TAG 3. create loxi-ccm daemonset using custom image In the DaemonSet section of the ./manifests/loxi-ccm.yaml file, change the image name to a custom image. (spec.template.spec.containers.image) --- apiVersion: apps/v1 kind: DaemonSet metadata: labels: k8s-app: loxi-cloud-controller-manager name: loxi-cloud-controller-manager namespace: kube-system spec: selector: matchLabels: k8s-app: loxi-cloud-controller-manager template: metadata: labels: k8s-app: loxi-cloud-controller-manager spec: serviceAccountName: loxi-cloud-controller-manager containers: - name: loxi-cloud-controller-manager imagePullPolicy: Always # for in-tree providers we use k8s.gcr.io/cloud-controller-manager # this can be replaced with any other image for out-of-tree providers image: {DOCKER_ID}/loxi-ccm:{TAG} command: - /bin/loxi-cloud-controller-manager","title":"Howto - ccm plugin"},{"location":"ccm/#howto-ccm-plugin","text":"loxi-ccm is a cloud-manager that provides kubernetes with loxilb load balancer. kubernetes provides the cloud-provider interface for the implementation of external cloud provider-specific logic, and loxi-ccm is an implementation of the cloud-provider interface.","title":"Howto - ccm plugin"},{"location":"ccm/#typical-loxi-ccm-deployment-topology","text":"As seen in the loxilb architecture documentation , loxi-ccm is logically shown as part of the loxilb cluster. But it's actually running on the k8s master/control-plane node. loxi-ccm implements the k8s load balancer service function using RESTful API of loxilb. When a user creates a k8s load balancer type service, loxi-ccm allocates an IP from the registered External IP subnet Pool. loxi-ccm sets rules in loxilb to allow service access from external with the assigned IP. In other words, loxi-ccm needs two information. loxilb API server address External IP Subnet These informations are managed through k8s ConfigMap. loxi-ccm users should modify this informations to suit your environment.","title":"Typical loxi-ccm deployment topology"},{"location":"ccm/#deploy-loxi-ccm-on-kubernetes","text":"The guide below has been tested in environment on Ubuntu 20.04, kubernetes v1.24 (calico CNI)","title":"Deploy loxi-ccm on kubernetes"},{"location":"ccm/#1-modify-k8s-configmap","text":"In the manifests/loxi-ccm.yaml manifests file, the ConfigMap is defined as follows --- apiVersion: v1 kind: ConfigMap metadata: name: loxilb-config namespace: kube-system data: apiServerURL: \"http://192.168.20.54:11111\" externalIPcidr: 123.123.123.0/24 --- The ConfigMap has two values: apiServerURL and externalIPcidr. apiServerURL : API Server address of loxilb. externalIPcidr : Subnet band to be allocated by loxilb as External IP of the load balancer. apiServerURL and externalIPcidr must be modified according to the environment of the user using loxi-ccm.","title":"1. Modify k8s ConfigMap"},{"location":"ccm/#2-deploy-loxi-ccm","text":"Once you have modified ConfigMap, you can deploy loxi-ccm using the loxi-ccm.yaml manifest file. Run the following command on the kubernetes you want to deploy. kubectl apply -f loxi-ccm.yaml After entering the command, check whether loxi-cloud-controller-manager is created in the daemonset of the kube-system namespace.","title":"2. Deploy loxi-ccm"},{"location":"ccm/#manual-build","text":"If you want to build loxi-ccm manually, do the following:","title":"Manual build"},{"location":"ccm/#1-build","text":"./build.sh","title":"1. build"},{"location":"ccm/#2-build-upload-container-image","text":"Below is an example. This case use docker to build container images, and images is uploaded to docker hub. TAG=\"0.1\" DOCKER_ID=YOUR_DOCKER_ID sudo docker build -t $DOCKER_ID/loxi-ccm:$TAG -f ./Dockerfile . sudo docker push $DOCKER_ID/loxi-ccm:$TAG","title":"2. Build &amp; upload container image"},{"location":"ccm/#3-create-loxi-ccm-daemonset-using-custom-image","text":"In the DaemonSet section of the ./manifests/loxi-ccm.yaml file, change the image name to a custom image. (spec.template.spec.containers.image) --- apiVersion: apps/v1 kind: DaemonSet metadata: labels: k8s-app: loxi-cloud-controller-manager name: loxi-cloud-controller-manager namespace: kube-system spec: selector: matchLabels: k8s-app: loxi-cloud-controller-manager template: metadata: labels: k8s-app: loxi-cloud-controller-manager spec: serviceAccountName: loxi-cloud-controller-manager containers: - name: loxi-cloud-controller-manager imagePullPolicy: Always # for in-tree providers we use k8s.gcr.io/cloud-controller-manager # this can be replaced with any other image for out-of-tree providers image: {DOCKER_ID}/loxi-ccm:{TAG} command: - /bin/loxi-cloud-controller-manager","title":"3. create loxi-ccm daemonset using custom image"},{"location":"cmd/","text":"What is loxicmd loxicmd is command tools for loxilb. loxicmd provide the following : Add/Delete/Get about the service type external load-balancer Get Port(interface) dump Get Connection track information loxicmd aim to provide all of the configuation for the loxilb. How to build Install package dependencies go get . Make loxicmd make How to run Run loxicmd with getting lb information ./loxicmd get lb Run loxicmd with getting lb information in the different API server(ex. 192.168.18.10) and ports(ex. 8099). ./loxicmd get lb -s 192.168.18.10 -p 8099 Run loxicmd with getting lb information as json output format ./loxicmd get lb -o json Run loxicmd with adding lb information ./loxicmd create lb 1.1.1.1 --tcp=1828:1920 --endpoints=2.2.3.4:18 Run loxicmd with deleting lb information ./loxicmd delete lb 1.1.1.1 --tcp=1828 Run loxicmd with getting connection track information ./loxicmd get conntrack Run loxicmd with getting port dumps ./loxicmd get port More information use help option! ./loxicmd help loxicmd development guide It will provide a guide for development. Please develop it according to the guidelines. The guide is divided into three main stages: design, development, and testing, and the details are as follows. API check and command design Before developing Command, we need to check if the API of the necessary functions is provided. Check the official API document of LoxiLB to see if the required API is provided. Afterwards, the GET, POST, and DELETE methods are designed with get, create, and delete commands according to the API provided. loxicmd$ tree . \u251c\u2500\u2500 AUTHORS \u251c\u2500\u2500 cmd \u2502 \u251c\u2500\u2500 create \u2502 \u2502 \u251c\u2500\u2500 create.go \u2502 \u2502 \u2514\u2500\u2500 create_loadbalancer.go \u2502 \u251c\u2500\u2500 delete \u2502 \u2502 \u251c\u2500\u2500 delete.go \u2502 \u2502 \u2514\u2500\u2500 delete_loadbalancer.go \u2502 \u251c\u2500\u2500 get \u2502 \u2502 \u251c\u2500\u2500 get.go \u2502 \u2502 \u251c\u2500\u2500 get_loadbalancer.go \u2502 \u2514\u2500\u2500 root.go \u251c\u2500\u2500 go.mod \u251c\u2500\u2500 go.sum \u251c\u2500\u2500 LICENSE \u251c\u2500\u2500 main.go \u251c\u2500\u2500 Makefile \u251c\u2500\u2500 pkg \u2502 \u2514\u2500\u2500 api \u2502 \u251c\u2500\u2500 client.go \u2502 \u251c\u2500\u2500 common.go \u2502 \u251c\u2500\u2500 loadBalancer.go \u2502 \u2514\u2500\u2500 rest.go \u2514\u2500\u2500 README.md Add the code in the ./cmd/get, ./cmd/delete, ./cmd/create, and ./pkg/api directories to add functionality. Add structure in pkg/api and register method (example of connection track API) CommonAPI embedding Using embedding the CommonAPI for the Methods and variables, to use in the Connecttrack structure. type Conntrack struct { CommonAPI } Add Structure Configuration and JSON Structure Define the structure for JSON Unmashal. type CtInformationGet struct { CtInfo []ConntrackInformation `json:\"ctAttr\"` } type ConntrackInformation struct { Dip string `json:\"destinationIP\"` Sip string `json:\"sourceIP\"` Dport uint16 `json:\"destinationPort\"` Sport uint16 `json:\"sourcePort\"` Proto string `json:\"protocol\"` CState string `json:\"conntrackState\"` CAct string `json:\"conntrackAct\"` } Define Method Functions in pkg/api/client.go Define the URL in the Resource constant. Defines the function to be used in the command. const ( \u2026 loxiConntrackResource = \"config/conntrack/all\" ) func (l *LoxiClient) Conntrack() *Conntrack { return &Conntrack{ CommonAPI: CommonAPI{ restClient: &l.restClient, requestInfo: RequestInfo{ provider: loxiProvider, apiVersion: loxiApiVersion, resource: loxiConntrackResource, }, }, } } Add get, create, delete functions within cmd Use the Cobra library to define commands, Alise, descriptions, options, and callback functions, and then create a function that returns. Create a function such as PrintGetCTReturn and add logic when the status code is 200. func NewGetConntrackCmd(restOptions *api.RESTOptions) *cobra.Command { var GetctCmd = &cobra.Command{ Use: \"conntrack\", Aliases: []string{\"ct\", \"conntracks\", \"cts\"}, Short: \"Get a Conntrack\", Long: `It shows connection track Information`, Run: func(cmd *cobra.Command, args []string) { client := api.NewLoxiClient(restOptions) ctx := context.TODO() var cancel context.CancelFunc if restOptions.Timeout > 0 { ctx, cancel = context.WithTimeout(context.TODO(), time.Duration(restOptions.Timeout)*time.Second) defer cancel() } resp, err := client.Conntrack().Get(ctx) if err != nil { fmt.Printf(\"Error: %s\\n\", err.Error()) return } if resp.StatusCode == http.StatusOK { PrintGetCTResult(resp, *restOptions) return } }, } return GetctCmd } Register command in cmd Register Cobra as defined in 3. func GetCmd(restOptions *api.RESTOptions) *cobra.Command { var GetCmd = &cobra.Command{ Use: \"get\", Short: \"A brief description of your command\", Long: `A longer description that spans multiple lines and likely contains examples and usage of using your command. For example: Cobra is a CLI library for Go that empowers applications. This application is a tool to generate the needed files to quickly Get a Cobra application.`, Run: func(cmd *cobra.Command, args []string) { fmt.Println(\"Get called\") }, } GetCmd.AddCommand(NewGetLoadBalancerCmd(restOptions)) GetCmd.AddCommand(NewGetConntrackCmd(restOptions)) return GetCmd } Build & Test make Test the command as you want!","title":"Cmd/Config guide"},{"location":"cmd/#what-is-loxicmd","text":"loxicmd is command tools for loxilb. loxicmd provide the following : Add/Delete/Get about the service type external load-balancer Get Port(interface) dump Get Connection track information loxicmd aim to provide all of the configuation for the loxilb.","title":"What is loxicmd"},{"location":"cmd/#how-to-build","text":"Install package dependencies go get . Make loxicmd make","title":"How to build"},{"location":"cmd/#how-to-run","text":"Run loxicmd with getting lb information ./loxicmd get lb Run loxicmd with getting lb information in the different API server(ex. 192.168.18.10) and ports(ex. 8099). ./loxicmd get lb -s 192.168.18.10 -p 8099 Run loxicmd with getting lb information as json output format ./loxicmd get lb -o json Run loxicmd with adding lb information ./loxicmd create lb 1.1.1.1 --tcp=1828:1920 --endpoints=2.2.3.4:18 Run loxicmd with deleting lb information ./loxicmd delete lb 1.1.1.1 --tcp=1828 Run loxicmd with getting connection track information ./loxicmd get conntrack Run loxicmd with getting port dumps ./loxicmd get port More information use help option! ./loxicmd help","title":"How to run"},{"location":"cmd/#loxicmd-development-guide","text":"It will provide a guide for development. Please develop it according to the guidelines. The guide is divided into three main stages: design, development, and testing, and the details are as follows. API check and command design Before developing Command, we need to check if the API of the necessary functions is provided. Check the official API document of LoxiLB to see if the required API is provided. Afterwards, the GET, POST, and DELETE methods are designed with get, create, and delete commands according to the API provided. loxicmd$ tree . \u251c\u2500\u2500 AUTHORS \u251c\u2500\u2500 cmd \u2502 \u251c\u2500\u2500 create \u2502 \u2502 \u251c\u2500\u2500 create.go \u2502 \u2502 \u2514\u2500\u2500 create_loadbalancer.go \u2502 \u251c\u2500\u2500 delete \u2502 \u2502 \u251c\u2500\u2500 delete.go \u2502 \u2502 \u2514\u2500\u2500 delete_loadbalancer.go \u2502 \u251c\u2500\u2500 get \u2502 \u2502 \u251c\u2500\u2500 get.go \u2502 \u2502 \u251c\u2500\u2500 get_loadbalancer.go \u2502 \u2514\u2500\u2500 root.go \u251c\u2500\u2500 go.mod \u251c\u2500\u2500 go.sum \u251c\u2500\u2500 LICENSE \u251c\u2500\u2500 main.go \u251c\u2500\u2500 Makefile \u251c\u2500\u2500 pkg \u2502 \u2514\u2500\u2500 api \u2502 \u251c\u2500\u2500 client.go \u2502 \u251c\u2500\u2500 common.go \u2502 \u251c\u2500\u2500 loadBalancer.go \u2502 \u2514\u2500\u2500 rest.go \u2514\u2500\u2500 README.md Add the code in the ./cmd/get, ./cmd/delete, ./cmd/create, and ./pkg/api directories to add functionality. Add structure in pkg/api and register method (example of connection track API) CommonAPI embedding Using embedding the CommonAPI for the Methods and variables, to use in the Connecttrack structure. type Conntrack struct { CommonAPI } Add Structure Configuration and JSON Structure Define the structure for JSON Unmashal. type CtInformationGet struct { CtInfo []ConntrackInformation `json:\"ctAttr\"` } type ConntrackInformation struct { Dip string `json:\"destinationIP\"` Sip string `json:\"sourceIP\"` Dport uint16 `json:\"destinationPort\"` Sport uint16 `json:\"sourcePort\"` Proto string `json:\"protocol\"` CState string `json:\"conntrackState\"` CAct string `json:\"conntrackAct\"` } Define Method Functions in pkg/api/client.go Define the URL in the Resource constant. Defines the function to be used in the command. const ( \u2026 loxiConntrackResource = \"config/conntrack/all\" ) func (l *LoxiClient) Conntrack() *Conntrack { return &Conntrack{ CommonAPI: CommonAPI{ restClient: &l.restClient, requestInfo: RequestInfo{ provider: loxiProvider, apiVersion: loxiApiVersion, resource: loxiConntrackResource, }, }, } } Add get, create, delete functions within cmd Use the Cobra library to define commands, Alise, descriptions, options, and callback functions, and then create a function that returns. Create a function such as PrintGetCTReturn and add logic when the status code is 200. func NewGetConntrackCmd(restOptions *api.RESTOptions) *cobra.Command { var GetctCmd = &cobra.Command{ Use: \"conntrack\", Aliases: []string{\"ct\", \"conntracks\", \"cts\"}, Short: \"Get a Conntrack\", Long: `It shows connection track Information`, Run: func(cmd *cobra.Command, args []string) { client := api.NewLoxiClient(restOptions) ctx := context.TODO() var cancel context.CancelFunc if restOptions.Timeout > 0 { ctx, cancel = context.WithTimeout(context.TODO(), time.Duration(restOptions.Timeout)*time.Second) defer cancel() } resp, err := client.Conntrack().Get(ctx) if err != nil { fmt.Printf(\"Error: %s\\n\", err.Error()) return } if resp.StatusCode == http.StatusOK { PrintGetCTResult(resp, *restOptions) return } }, } return GetctCmd } Register command in cmd Register Cobra as defined in 3. func GetCmd(restOptions *api.RESTOptions) *cobra.Command { var GetCmd = &cobra.Command{ Use: \"get\", Short: \"A brief description of your command\", Long: `A longer description that spans multiple lines and likely contains examples and usage of using your command. For example: Cobra is a CLI library for Go that empowers applications. This application is a tool to generate the needed files to quickly Get a Cobra application.`, Run: func(cmd *cobra.Command, args []string) { fmt.Println(\"Get called\") }, } GetCmd.AddCommand(NewGetLoadBalancerCmd(restOptions)) GetCmd.AddCommand(NewGetConntrackCmd(restOptions)) return GetCmd } Build & Test make Test the command as you want!","title":"loxicmd development guide"},{"location":"code/","text":"loxilb is organized as below: \u251c\u2500\u2500 api \u2502 \u251c\u2500\u2500 certification \u2502 \u251c\u2500\u2500 cmd \u2502 \u2502 \u251c\u2500\u2500 loxilb-rest-api-server \u2502 \u251c\u2500\u2500 models \u2502 \u251c\u2500\u2500 restapi \u2502 \u251c\u2500\u2500 handler \u2502 \u251c\u2500\u2500 operations \u251c\u2500\u2500 common \u251c\u2500\u2500 ebpf \u2502 \u251c\u2500\u2500 common \u2502 \u251c\u2500\u2500 headers \u2502 \u2502 \u251c\u2500\u2500 linux \u2502 \u251c\u2500\u2500 kernel \u2502 \u251c\u2500\u2500 libbpf \u2502 \u2502 \u251c\u2500\u2500 include \u2502 \u2502 \u2502 \u251c\u2500\u2500 asm \u2502 \u2502 \u2502 \u251c\u2500\u2500 linux \u2502 \u2502 \u2502 \u251c\u2500\u2500 uapi \u2502 \u2502 \u2502 \u251c\u2500\u2500 linux \u2502 \u2502 \u251c\u2500\u2500 scripts \u2502 \u2502 \u251c\u2500\u2500 src \u2502 \u2502 \u2502 \u251c\u2500\u2500 build \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 usr \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 include \u2502 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 bpf \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 lib64 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 pkgconfig \u2502 \u2502 \u2502 \u251c\u2500\u2500 sharedobjs \u2502 \u2502 \u2502 \u251c\u2500\u2500 staticobjs \u2502 \u2502 \u251c\u2500\u2500 travis-ci \u2502 \u2502 \u251c\u2500\u2500 managers \u2502 \u2502 \u251c\u2500\u2500 vmtest \u2502 \u2502 \u251c\u2500\u2500 configs \u2502 \u2502 \u251c\u2500\u2500 blacklist \u2502 \u2502 \u251c\u2500\u2500 whitelist \u2502 \u251c\u2500\u2500 utils \u251c\u2500\u2500 loxilib \u251c\u2500\u2500 loxinet \u251c\u2500\u2500 loxinlp \u251c\u2500\u2500 options api This directory contains source code to host api server to handle CCM configuration requests. common Common api to configure which are exposed by loxinet are defined in this directory. loxinet This module implements the glue layer or the middle layer between eBPF datapath module and api modules. It defines functions for configuring networking and load balancing rules in the eBPF datapath. ebpf This directory contains source code for loxilb eBPF datapath. loxilib This directory contains common libraries for logging, statistics and other utilities. loxinlp This directory implements the package for reading and writing the network information through linux's netlink interface. options This directory contains files for managing the command line options.","title":"Code organization"},{"location":"code/#loxilb-is-organized-as-below","text":"\u251c\u2500\u2500 api \u2502 \u251c\u2500\u2500 certification \u2502 \u251c\u2500\u2500 cmd \u2502 \u2502 \u251c\u2500\u2500 loxilb-rest-api-server \u2502 \u251c\u2500\u2500 models \u2502 \u251c\u2500\u2500 restapi \u2502 \u251c\u2500\u2500 handler \u2502 \u251c\u2500\u2500 operations \u251c\u2500\u2500 common \u251c\u2500\u2500 ebpf \u2502 \u251c\u2500\u2500 common \u2502 \u251c\u2500\u2500 headers \u2502 \u2502 \u251c\u2500\u2500 linux \u2502 \u251c\u2500\u2500 kernel \u2502 \u251c\u2500\u2500 libbpf \u2502 \u2502 \u251c\u2500\u2500 include \u2502 \u2502 \u2502 \u251c\u2500\u2500 asm \u2502 \u2502 \u2502 \u251c\u2500\u2500 linux \u2502 \u2502 \u2502 \u251c\u2500\u2500 uapi \u2502 \u2502 \u2502 \u251c\u2500\u2500 linux \u2502 \u2502 \u251c\u2500\u2500 scripts \u2502 \u2502 \u251c\u2500\u2500 src \u2502 \u2502 \u2502 \u251c\u2500\u2500 build \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 usr \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 include \u2502 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 bpf \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 lib64 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 pkgconfig \u2502 \u2502 \u2502 \u251c\u2500\u2500 sharedobjs \u2502 \u2502 \u2502 \u251c\u2500\u2500 staticobjs \u2502 \u2502 \u251c\u2500\u2500 travis-ci \u2502 \u2502 \u251c\u2500\u2500 managers \u2502 \u2502 \u251c\u2500\u2500 vmtest \u2502 \u2502 \u251c\u2500\u2500 configs \u2502 \u2502 \u251c\u2500\u2500 blacklist \u2502 \u2502 \u251c\u2500\u2500 whitelist \u2502 \u251c\u2500\u2500 utils \u251c\u2500\u2500 loxilib \u251c\u2500\u2500 loxinet \u251c\u2500\u2500 loxinlp \u251c\u2500\u2500 options","title":"loxilb is organized as below:"},{"location":"code/#api","text":"This directory contains source code to host api server to handle CCM configuration requests.","title":"api"},{"location":"code/#common","text":"Common api to configure which are exposed by loxinet are defined in this directory.","title":"common"},{"location":"code/#loxinet","text":"This module implements the glue layer or the middle layer between eBPF datapath module and api modules. It defines functions for configuring networking and load balancing rules in the eBPF datapath.","title":"loxinet"},{"location":"code/#ebpf","text":"This directory contains source code for loxilb eBPF datapath.","title":"ebpf"},{"location":"code/#loxilib","text":"This directory contains common libraries for logging, statistics and other utilities.","title":"loxilib"},{"location":"code/#loxinlp","text":"This directory implements the package for reading and writing the network information through linux's netlink interface.","title":"loxinlp"},{"location":"code/#options","text":"This directory contains files for managing the command line options.","title":"options"},{"location":"contribute/","text":"Contributing When contributing to any of loxilb's repositories, please first discuss the change you wish to make via issue, email, or any other method with the owners of this repository before making a change. Please note we have a code of conduct, please follow it in all your interactions with the project. Pull Request Process Ensure any install or build dependencies are removed before the end of the layer when doing a build. Update the README.md with details of changes to the interface, this includes new environment variables, exposed ports, useful file locations and container parameters. Increase the version numbers in any examples files and the README.md to the new version that this Pull Request would represent. The versioning scheme we use is SemVer . You may merge the Pull Request in once you have the sign-off of two other developers, or if you do not have permission to do that, you may request the second reviewer to merge it for you. For Pull Requests to be successfully merged to main branch : It has to be code-reviewed by the maintainer(s) Integrated Travis-CI runs should pass without errors Detailed instructions to help new developers setup the development/test environment can be found here Alternatively, they can email developers at [loxilb-devel@netlox.io]. , checkout existing issues in github , visit the loxilb forum or loxilb slack channel Sign Your Commits Instructions DCO Licensing is important to open source projects. It provides some assurances that the software will continue to be available based under the terms that the author(s) desired. We require that contributors sign off on commits submitted to our project's repositories. The Developer Certificate of Origin (DCO) is a way to certify that you wrote and have the right to contribute the code you are submitting to the project. You sign-off by adding the following to your commit messages. Your sign-off must match the git user and email associated with the commit. This is my commit message Signed-off-by: Your Name <your.name@example.com> Git has a -s command line option to do this automatically: git commit -s -m 'This is my commit message' If you forgot to do this and have not yet pushed your changes to the remote repository, you can amend your commit with the sign-off by running git commit --amend -s Code of Conduct Our Pledge In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, nationality, personal appearance, race, religion, or sexual identity and orientation. Our Standards Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting Our Responsibilities Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful. Scope This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers. Enforcement Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at [loxilb-devel@netlox.io]. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership. Attribution This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available at http://contributor-covenant.org/version/1/4","title":"Contribute"},{"location":"contribute/#contributing","text":"When contributing to any of loxilb's repositories, please first discuss the change you wish to make via issue, email, or any other method with the owners of this repository before making a change. Please note we have a code of conduct, please follow it in all your interactions with the project.","title":"Contributing"},{"location":"contribute/#pull-request-process","text":"Ensure any install or build dependencies are removed before the end of the layer when doing a build. Update the README.md with details of changes to the interface, this includes new environment variables, exposed ports, useful file locations and container parameters. Increase the version numbers in any examples files and the README.md to the new version that this Pull Request would represent. The versioning scheme we use is SemVer . You may merge the Pull Request in once you have the sign-off of two other developers, or if you do not have permission to do that, you may request the second reviewer to merge it for you. For Pull Requests to be successfully merged to main branch : It has to be code-reviewed by the maintainer(s) Integrated Travis-CI runs should pass without errors Detailed instructions to help new developers setup the development/test environment can be found here Alternatively, they can email developers at [loxilb-devel@netlox.io]. , checkout existing issues in github , visit the loxilb forum or loxilb slack channel","title":"Pull Request Process"},{"location":"contribute/#sign-your-commits","text":"Instructions","title":"Sign Your Commits"},{"location":"contribute/#dco","text":"Licensing is important to open source projects. It provides some assurances that the software will continue to be available based under the terms that the author(s) desired. We require that contributors sign off on commits submitted to our project's repositories. The Developer Certificate of Origin (DCO) is a way to certify that you wrote and have the right to contribute the code you are submitting to the project. You sign-off by adding the following to your commit messages. Your sign-off must match the git user and email associated with the commit. This is my commit message Signed-off-by: Your Name <your.name@example.com> Git has a -s command line option to do this automatically: git commit -s -m 'This is my commit message' If you forgot to do this and have not yet pushed your changes to the remote repository, you can amend your commit with the sign-off by running git commit --amend -s","title":"DCO"},{"location":"contribute/#code-of-conduct","text":"","title":"Code of Conduct"},{"location":"contribute/#our-pledge","text":"In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, nationality, personal appearance, race, religion, or sexual identity and orientation.","title":"Our Pledge"},{"location":"contribute/#our-standards","text":"Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting","title":"Our Standards"},{"location":"contribute/#our-responsibilities","text":"Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.","title":"Our Responsibilities"},{"location":"contribute/#scope","text":"This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.","title":"Scope"},{"location":"contribute/#enforcement","text":"Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at [loxilb-devel@netlox.io]. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.","title":"Enforcement"},{"location":"contribute/#attribution","text":"This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available at http://contributor-covenant.org/version/1/4","title":"Attribution"},{"location":"debugging/","text":"loxilb - How to debug Check loxilb logs loxilb logs its various important events and logs in the file /var/log/loxilb.log. Users can check it by using tail -f or any other command of choice. root@752531364e2c:/# tail -f /var/log/loxilb.log DBG: 2022/07/10 12:49:27 1:dst-10.10.10.1/32,proto-6,dport-2020,,do-dnat:eip-31.31.31.1,ep-5001,w-1,alive|eip-32.32.32.1,ep-5001,w-2,alive|eip-100.100.100.1,ep-5001,w-2,alive| pc 0 bc 0 DBG: 2022/07/10 12:49:37 1:dst-10.10.10.1/32,proto-6,dport-2020,,do-dnat:eip-31.31.31.1,ep-5001,w-1,alive|eip-32.32.32.1,ep-5001,w-2,alive|eip-100.100.100.1,ep-5001,w-2,alive| pc 0 bc 0 DBG: 2022/07/10 12:49:47 1:dst-10.10.10.1/32,proto-6,dport-2020,,do-dnat:eip-31.31.31.1,ep-5001,w-1,alive|eip-32.32.32.1,ep-5001,w-2,alive|eip-100.100.100.1,ep-5001,w-2,alive| pc 0 bc 0 DBG: 2022/07/10 12:49:57 1:dst-10.10.10.1/32,proto-6,dport-2020,,do-dnat:eip-31.31.31.1,ep-5001,w-1,alive|eip-32.32.32.1,ep-5001,w-2,alive|eip-100.100.100.1,ep-5001,w-2,alive| pc 0 bc 0 DBG: 2022/07/10 12:50:07 1:dst-10.10.10.1/32,proto-6,dport-2020,,do-dnat:eip-31.31.31.1,ep-5001,w-1,alive|eip-32.32.32.1,ep-5001,w-2,alive|eip-100.100.100.1,ep-5001,w-2,alive| pc 0 bc 0 DBG: 2022/07/10 12:50:17 1:dst-10.10.10.1/32,proto-6,dport-2020,,do-dnat:eip-31.31.31.1,ep-5001,w-1,alive|eip-32.32.32.1,ep-5001,w-2,alive|eip-100.100.100.1,ep-5001,w-2,alive| pc 0 bc 0 DBG: 2022/07/10 12:50:27 1:dst-10.10.10.1/32,proto-6,dport-2020,,do-dnat:eip-31.31.31.1,ep-5001,w-1,alive|eip-32.32.32.1,ep-5001,w-2,alive|eip-100.100.100.1,ep-5001,w-2,alive| pc 0 bc 0 DBG: 2022/07/10 12:50:37 1:dst-10.10.10.1/32,proto-6,dport-2020,,do-dnat:eip-31.31.31.1,ep-5001,w-1,alive|eip-32.32.32.1,ep-5001,w-2,alive|eip-100.100.100.1,ep-5001,w-2,alive| pc 0 bc 0 DBG: 2022/07/10 12:50:47 1:dst-10.10.10.1/32,proto-6,dport-2020,,do-dnat:eip-31.31.31.1,ep-5001,w-1,alive|eip-32.32.32.1,ep-5001,w-2,alive|eip-100.100.100.1,ep-5001,w-2,alive| pc 0 bc 0 DBG: 2022/07/10 12:50:57 1:dst-10.10.10.1/32,proto-6,dport-2020,,do-dnat:eip-31.31.31.1,ep-5001,w-1,alive|eip-32.32.32.1,ep-5001,w-2,alive|eip-100.100.100.1,ep-5001,w-2,alive| pc 0 bc 0 Check loxicmd to debug loxilb's internal state ## Spawn a bash shell of loxilb docker docker exec -it loxilb bash root@752531364e2c:/# loxicmd get lb | EXTERNALIP | PORT | PROTOCOL | SELECT | # OF ENDPOINTS | |------------|------|----------|--------|----------------| | 10.10.10.1 | 2020 | tcp | 0 | 3 | root@752531364e2c:/# loxicmd get lb -o wide | EXTERNALIP | PORT | PROTOCOL | SELECT | ENDPOINTIP | TARGETPORT | WEIGHT | |------------|------|----------|--------|---------------|------------|--------| | 10.10.10.1 | 2020 | tcp | 0 | 31.31.31.1 | 5001 | 1 | | | | | | 32.32.32.1 | 5001 | 2 | | | | | | 100.100.100.1 | 5001 | 2 | root@0c4f9175c983:/# loxicmd get conntrack | DESTINATIONIP | SOURCEIP | DESTINATIONPORT | SOURCEPORT | PROTOCOL | STATE | ACT | |---------------|------------|-----------------|------------|----------|-------------|-----| | 127.0.0.1 | 127.0.0.1 | 11111 | 47180 | tcp | closed-wait | | | 127.0.0.1 | 127.0.0.1 | 11111 | 47182 | tcp | est | | | 32.32.32.1 | 31.31.31.1 | 35068 | 35068 | icmp | bidir | | root@65ad9b2f1b7f:/# loxicmd get port | INDEX | PORTNAME | MAC | LINK/STATE | L3INFO | L2INFO | |-------|----------|-------------------|-------------|---------------|---------------| | 1 | lo | 00:00:00:00:00:00 | true/false | Routed: false | IsPVID: true | | | | | | IPv4 : [] | VID : 3801 | | | | | | IPv6 : [] | | | 2 | vlan3801 | aa:bb:cc:dd:ee:ff | true/true | Routed: false | IsPVID: false | | | | | | IPv4 : [] | VID : 3801 | | | | | | IPv6 : [] | | | 3 | llb0 | 42:6e:9b:7f:ff:36 | true/false | Routed: false | IsPVID: true | | | | | | IPv4 : [] | VID : 3803 | | | | | | IPv6 : [] | | | 4 | vlan3803 | aa:bb:cc:dd:ee:ff | true/true | Routed: false | IsPVID: false | | | | | | IPv4 : [] | VID : 3803 | | | | | | IPv6 : [] | | | 5 | eth0 | 02:42:ac:1e:01:c1 | true/true | Routed: false | IsPVID: true | | | | | | IPv4 : [] | VID : 3805 | | | | | | IPv6 : [] | | | 6 | vlan3805 | aa:bb:cc:dd:ee:ff | true/true | Routed: false | IsPVID: false | | | | | | IPv4 : [] | VID : 3805 | | | | | | IPv6 : [] | | | 7 | enp1 | fe:84:23:ac:41:31 | false/false | Routed: false | IsPVID: true | | | | | | IPv4 : [] | VID : 3807 | | | | | | IPv6 : [] | | | 8 | vlan3807 | aa:bb:cc:dd:ee:ff | true/true | Routed: false | IsPVID: false | | | | | | IPv4 : [] | VID : 3807 | | | | | | IPv6 : [] | | | 9 | enp2 | d6:3c:7f:9e:58:5c | false/false | Routed: false | IsPVID: true | | | | | | IPv4 : [] | VID : 3809 | | | | | | IPv6 : [] | | | 10 | vlan3809 | aa:bb:cc:dd:ee:ff | true/true | Routed: false | IsPVID: false | | | | | | IPv4 : [] | VID : 3809 | | | | | | IPv6 : [] | | | 11 | enp2v15 | 8a:9e:99:aa:f9:c3 | false/false | Routed: false | IsPVID: true | | | | | | IPv4 : [] | VID : 3811 | | | | | | IPv6 : [] | | | 12 | vlan3811 | aa:bb:cc:dd:ee:ff | true/true | Routed: false | IsPVID: false | | | | | | IPv4 : [] | VID : 3811 | | | | | | IPv6 : [] | | | 13 | enp3 | f2:c7:4b:ac:fd:3e | false/false | Routed: false | IsPVID: true | | | | | | IPv4 : [] | VID : 3813 | | | | | | IPv6 : [] | | | 14 | vlan3813 | aa:bb:cc:dd:ee:ff | true/true | Routed: false | IsPVID: false | | | | | | IPv4 : [] | VID : 3813 | | | | | | IPv6 : [] | | | 15 | enp4 | 12:d2:c3:79:f3:6a | false/false | Routed: false | IsPVID: true | | | | | | IPv4 : [] | VID : 3815 | | | | | | IPv6 : [] | | | 16 | vlan3815 | aa:bb:cc:dd:ee:ff | true/true | Routed: false | IsPVID: false | | | | | | IPv4 : [] | VID : 3815 | | | | | | IPv6 : [] | | | 17 | vlan100 | 56:2e:76:b2:71:48 | false/false | Routed: false | IsPVID: false | | | | | | IPv4 : [] | VID : 100 | | | | | | IPv6 : [] | | Debug loxilb kernel and eBPF components loxilb uses various eBPF maps as part of its DP implementation. These maps are pinned to OS filesystem and can be further used with bpftool to debug. root@0c4f9175c983:/# ls -lart /opt/loxilb/dp/bpf/ total 0 -rw------- 1 root root 0 Jul 10 11:32 xfis -rw------- 1 root root 0 Jul 10 11:32 xfck -rw------- 1 root root 0 Jul 10 11:32 xctk -rw------- 1 root root 0 Jul 10 11:32 tx_intf_stats_map -rw------- 1 root root 0 Jul 10 11:32 tx_intf_map -rw------- 1 root root 0 Jul 10 11:32 tx_bd_stats_map -rw------- 1 root root 0 Jul 10 11:32 tmac_stats_map -rw------- 1 root root 0 Jul 10 11:32 tmac_map -rw------- 1 root root 0 Jul 10 11:32 smac_map -rw------- 1 root root 0 Jul 10 11:32 sess_v4_stats_map -rw------- 1 root root 0 Jul 10 11:32 sess_v4_map -rw------- 1 root root 0 Jul 10 11:32 rt_v6_stats_map -rw------- 1 root root 0 Jul 10 11:32 rt_v4_stats_map -rw------- 1 root root 0 Jul 10 11:32 rt_v4_map -rw------- 1 root root 0 Jul 10 11:32 polx_map -rw------- 1 root root 0 Jul 10 11:32 pkts -rw------- 1 root root 0 Jul 10 11:32 pkt_ring -rw------- 1 root root 0 Jul 10 11:32 pgm_tbl -rw------- 1 root root 0 Jul 10 11:32 nat_v4_map -rw------- 1 root root 0 Jul 10 11:32 mirr_map -rw------- 1 root root 0 Jul 10 11:32 intf_stats_map -rw------- 1 root root 0 Jul 10 11:32 intf_map -rw------- 1 root root 0 Jul 10 11:32 fcas -rw------- 1 root root 0 Jul 10 11:32 fc_v4_stats_map -rw------- 1 root root 0 Jul 10 11:32 fc_v4_map -rw------- 1 root root 0 Jul 10 11:32 dmac_map -rw------- 1 root root 0 Jul 10 11:32 ct_v4_map -rw------- 1 root root 0 Jul 10 11:32 bd_stats_map -rw------- 1 root root 0 Jul 10 11:32 acl_v6_stats_map -rw------- 1 root root 0 Jul 10 11:32 acl_v4_stats_map -rw------- 1 root root 0 Jul 10 11:32 acl_v4_map drwxrwxrwt 3 root root 0 Jul 10 11:32 .. lrwxrwxrwx 1 root root 0 Jul 10 11:32 xdp -> /opt/loxilb/dp/bpf//tc/ drwx------ 3 root root 0 Jul 10 11:32 tc lrwxrwxrwx 1 root root 0 Jul 10 11:32 ip -> /opt/loxilb/dp/bpf//tc/ root@752531364e2c:/# bpftool map dump pinned /opt/loxilb/dp/bpf/intf_map [{ \"key\": { \"ifindex\": 2, \"ing_vid\": 0, \"pad\": 0 }, \"value\": { \"ca\": { \"act_type\": 11, \"ftrap\": 0, \"oif\": 0, \"cidx\": 0 }, \"\": { \"set_ifi\": { \"xdp_ifidx\": 1, \"zone\": 0, \"bd\": 3801, \"mirr\": 0, \"polid\": 0, \"r\": [0,0,0,0,0,0 ] } } } },{ \"key\": { \"ifindex\": 3, \"ing_vid\": 0, \"pad\": 0 }, \"value\": { \"ca\": { \"act_type\": 11, \"ftrap\": 0, \"oif\": 0, \"cidx\": 0 }, \"\": { \"set_ifi\": { \"xdp_ifidx\": 3, \"zone\": 0, \"bd\": 3803, \"mirr\": 0, \"polid\": 0, \"r\": [0,0,0,0,0,0 ] } } } } ] root@752531364e2c:/# bpftool map dump pinned /opt/loxilb/dp/bpf/nat_v4_map [{ \"key\": { \"daddr\": 17435146, \"dport\": 58375, \"zone\": 0, \"l4proto\": 6 }, \"value\": { \"ca\": { \"act_type\": 5, \"ftrap\": 0, \"oif\": 0, \"cidx\": 1 }, \"lock\": { \"val\": 0 }, \"nxfrm\": 3, \"sel_hint\": 0, \"sel_type\": 0, \"nxfrms\": [{ \"nat_flags\": 0, \"inactive\": 0, \"wprio\": 1, \"res\": 0, \"nat_xport\": 35091, \"nat_xip\": 18816799 },{ \"nat_flags\": 0, \"inactive\": 0, \"wprio\": 2, \"res\": 0, \"nat_xport\": 35091, \"nat_xip\": 18882592 },{ \"nat_flags\": 0, \"inactive\": 0, \"wprio\": 2, \"res\": 0, \"nat_xport\": 35091, \"nat_xip\": 23356516 },{ \"nat_flags\": 0, \"inactive\": 1, \"wprio\": 0, \"res\": 0, \"nat_xport\": 0, \"nat_xip\": 0 },{ \"nat_flags\": 0, \"inactive\": 1, \"wprio\": 0, \"res\": 0, \"nat_xport\": 0, \"nat_xip\": 0 },{ \"nat_flags\": 0, \"inactive\": 1, \"wprio\": 0, \"res\": 0, \"nat_xport\": 0, \"nat_xip\": 0 },{ \"nat_flags\": 0, \"inactive\": 1, \"wprio\": 0, \"res\": 0, \"nat_xport\": 0, \"nat_xip\": 0 },{ \"nat_flags\": 0, \"inactive\": 1, \"wprio\": 0, \"res\": 0, \"nat_xport\": 0, \"nat_xip\": 0 },{ \"nat_flags\": 0, \"inactive\": 1, \"wprio\": 0, \"res\": 0, \"nat_xport\": 0, \"nat_xip\": 0 },{ \"nat_flags\": 0, \"inactive\": 1, \"wprio\": 0, \"res\": 0, \"nat_xport\": 0, \"nat_xip\": 0 },{ \"nat_flags\": 0, \"inactive\": 1, \"wprio\": 0, \"res\": 0, \"nat_xport\": 0, \"nat_xip\": 0 },{ \"nat_flags\": 0, \"inactive\": 1, \"wprio\": 0, \"res\": 0, \"nat_xport\": 0, \"nat_xip\": 0 },{ \"nat_flags\": 0, \"inactive\": 1, \"wprio\": 0, \"res\": 0, \"nat_xport\": 0, \"nat_xip\": 0 },{ \"nat_flags\": 0, \"inactive\": 1, \"wprio\": 0, \"res\": 0, \"nat_xport\": 0, \"nat_xip\": 0 },{ \"nat_flags\": 0, \"inactive\": 1, \"wprio\": 0, \"res\": 0, \"nat_xport\": 0, \"nat_xip\": 0 },{ \"nat_flags\": 0, \"inactive\": 1, \"wprio\": 0, \"res\": 0, \"nat_xport\": 0, \"nat_xip\": 0 } ] } } ] Check eBPF kernel debug logs Last but not the least, linux kernel outputs generic eBPF debug logs to /sys/kernel/debug/tracing/trace_pipe. Although loxilb eBPF modules do not emit logs in normal mode of operation, logs can be enabled after a recompilation. root@752531364e2c:/# cat /sys/kernel/debug/tracing/trace_pipe loxicmd-30524 [001] d.s1 27870.170790: bpf_trace_printk: out-dir loxicmd-30524 [001] d.s1 27870.170791: bpf_trace_printk: smr 4 loxicmd-30529 [000] d.s1 27871.617467: bpf_trace_printk: [CTRK] start loxicmd-30529 [000] d.s1 27871.617484: bpf_trace_printk: new-ct4 loxicmd-30529 [000] d.s1 27871.617486: bpf_trace_printk: in-dir loxicmd-30529 [000] d.s1 27871.617488: bpf_trace_printk: smr 0 loxicmd-30529 [000] d.s1 27871.617503: bpf_trace_printk: [CTRK] start loxicmd-30529 [000] d.s1 27871.617503: bpf_trace_printk: out-dir loxicmd-30529 [000] d.s1 27871.617504: bpf_trace_printk: smr 4 sshd-30790 [000] d.s1 27970.031847: bpf_trace_printk: [CTRK] start sshd-30790 [000] d.s1 27970.031866: bpf_trace_printk: new-ct4 sshd-30790 [000] d.s1 27970.031868: bpf_trace_printk: in-dir sshd-30790 [000] d.s1 27970.031870: bpf_trace_printk: smr 0 sshd-30790 [000] d.s1 27970.031887: bpf_trace_printk: [CTRK] start sshd-30790 [000] d.s1 27970.031887: bpf_trace_printk: out-dir sshd-30790 [000] d.s1 27970.031888: bpf_trace_printk: smr 0 sshd-30790 [000] d.s1 27970.031900: bpf_trace_printk: [CTRK] start","title":"Howto - debug"},{"location":"debugging/#loxilb-how-to-debug","text":"Check loxilb logs loxilb logs its various important events and logs in the file /var/log/loxilb.log. Users can check it by using tail -f or any other command of choice. root@752531364e2c:/# tail -f /var/log/loxilb.log DBG: 2022/07/10 12:49:27 1:dst-10.10.10.1/32,proto-6,dport-2020,,do-dnat:eip-31.31.31.1,ep-5001,w-1,alive|eip-32.32.32.1,ep-5001,w-2,alive|eip-100.100.100.1,ep-5001,w-2,alive| pc 0 bc 0 DBG: 2022/07/10 12:49:37 1:dst-10.10.10.1/32,proto-6,dport-2020,,do-dnat:eip-31.31.31.1,ep-5001,w-1,alive|eip-32.32.32.1,ep-5001,w-2,alive|eip-100.100.100.1,ep-5001,w-2,alive| pc 0 bc 0 DBG: 2022/07/10 12:49:47 1:dst-10.10.10.1/32,proto-6,dport-2020,,do-dnat:eip-31.31.31.1,ep-5001,w-1,alive|eip-32.32.32.1,ep-5001,w-2,alive|eip-100.100.100.1,ep-5001,w-2,alive| pc 0 bc 0 DBG: 2022/07/10 12:49:57 1:dst-10.10.10.1/32,proto-6,dport-2020,,do-dnat:eip-31.31.31.1,ep-5001,w-1,alive|eip-32.32.32.1,ep-5001,w-2,alive|eip-100.100.100.1,ep-5001,w-2,alive| pc 0 bc 0 DBG: 2022/07/10 12:50:07 1:dst-10.10.10.1/32,proto-6,dport-2020,,do-dnat:eip-31.31.31.1,ep-5001,w-1,alive|eip-32.32.32.1,ep-5001,w-2,alive|eip-100.100.100.1,ep-5001,w-2,alive| pc 0 bc 0 DBG: 2022/07/10 12:50:17 1:dst-10.10.10.1/32,proto-6,dport-2020,,do-dnat:eip-31.31.31.1,ep-5001,w-1,alive|eip-32.32.32.1,ep-5001,w-2,alive|eip-100.100.100.1,ep-5001,w-2,alive| pc 0 bc 0 DBG: 2022/07/10 12:50:27 1:dst-10.10.10.1/32,proto-6,dport-2020,,do-dnat:eip-31.31.31.1,ep-5001,w-1,alive|eip-32.32.32.1,ep-5001,w-2,alive|eip-100.100.100.1,ep-5001,w-2,alive| pc 0 bc 0 DBG: 2022/07/10 12:50:37 1:dst-10.10.10.1/32,proto-6,dport-2020,,do-dnat:eip-31.31.31.1,ep-5001,w-1,alive|eip-32.32.32.1,ep-5001,w-2,alive|eip-100.100.100.1,ep-5001,w-2,alive| pc 0 bc 0 DBG: 2022/07/10 12:50:47 1:dst-10.10.10.1/32,proto-6,dport-2020,,do-dnat:eip-31.31.31.1,ep-5001,w-1,alive|eip-32.32.32.1,ep-5001,w-2,alive|eip-100.100.100.1,ep-5001,w-2,alive| pc 0 bc 0 DBG: 2022/07/10 12:50:57 1:dst-10.10.10.1/32,proto-6,dport-2020,,do-dnat:eip-31.31.31.1,ep-5001,w-1,alive|eip-32.32.32.1,ep-5001,w-2,alive|eip-100.100.100.1,ep-5001,w-2,alive| pc 0 bc 0 Check loxicmd to debug loxilb's internal state ## Spawn a bash shell of loxilb docker docker exec -it loxilb bash root@752531364e2c:/# loxicmd get lb | EXTERNALIP | PORT | PROTOCOL | SELECT | # OF ENDPOINTS | |------------|------|----------|--------|----------------| | 10.10.10.1 | 2020 | tcp | 0 | 3 | root@752531364e2c:/# loxicmd get lb -o wide | EXTERNALIP | PORT | PROTOCOL | SELECT | ENDPOINTIP | TARGETPORT | WEIGHT | |------------|------|----------|--------|---------------|------------|--------| | 10.10.10.1 | 2020 | tcp | 0 | 31.31.31.1 | 5001 | 1 | | | | | | 32.32.32.1 | 5001 | 2 | | | | | | 100.100.100.1 | 5001 | 2 | root@0c4f9175c983:/# loxicmd get conntrack | DESTINATIONIP | SOURCEIP | DESTINATIONPORT | SOURCEPORT | PROTOCOL | STATE | ACT | |---------------|------------|-----------------|------------|----------|-------------|-----| | 127.0.0.1 | 127.0.0.1 | 11111 | 47180 | tcp | closed-wait | | | 127.0.0.1 | 127.0.0.1 | 11111 | 47182 | tcp | est | | | 32.32.32.1 | 31.31.31.1 | 35068 | 35068 | icmp | bidir | | root@65ad9b2f1b7f:/# loxicmd get port | INDEX | PORTNAME | MAC | LINK/STATE | L3INFO | L2INFO | |-------|----------|-------------------|-------------|---------------|---------------| | 1 | lo | 00:00:00:00:00:00 | true/false | Routed: false | IsPVID: true | | | | | | IPv4 : [] | VID : 3801 | | | | | | IPv6 : [] | | | 2 | vlan3801 | aa:bb:cc:dd:ee:ff | true/true | Routed: false | IsPVID: false | | | | | | IPv4 : [] | VID : 3801 | | | | | | IPv6 : [] | | | 3 | llb0 | 42:6e:9b:7f:ff:36 | true/false | Routed: false | IsPVID: true | | | | | | IPv4 : [] | VID : 3803 | | | | | | IPv6 : [] | | | 4 | vlan3803 | aa:bb:cc:dd:ee:ff | true/true | Routed: false | IsPVID: false | | | | | | IPv4 : [] | VID : 3803 | | | | | | IPv6 : [] | | | 5 | eth0 | 02:42:ac:1e:01:c1 | true/true | Routed: false | IsPVID: true | | | | | | IPv4 : [] | VID : 3805 | | | | | | IPv6 : [] | | | 6 | vlan3805 | aa:bb:cc:dd:ee:ff | true/true | Routed: false | IsPVID: false | | | | | | IPv4 : [] | VID : 3805 | | | | | | IPv6 : [] | | | 7 | enp1 | fe:84:23:ac:41:31 | false/false | Routed: false | IsPVID: true | | | | | | IPv4 : [] | VID : 3807 | | | | | | IPv6 : [] | | | 8 | vlan3807 | aa:bb:cc:dd:ee:ff | true/true | Routed: false | IsPVID: false | | | | | | IPv4 : [] | VID : 3807 | | | | | | IPv6 : [] | | | 9 | enp2 | d6:3c:7f:9e:58:5c | false/false | Routed: false | IsPVID: true | | | | | | IPv4 : [] | VID : 3809 | | | | | | IPv6 : [] | | | 10 | vlan3809 | aa:bb:cc:dd:ee:ff | true/true | Routed: false | IsPVID: false | | | | | | IPv4 : [] | VID : 3809 | | | | | | IPv6 : [] | | | 11 | enp2v15 | 8a:9e:99:aa:f9:c3 | false/false | Routed: false | IsPVID: true | | | | | | IPv4 : [] | VID : 3811 | | | | | | IPv6 : [] | | | 12 | vlan3811 | aa:bb:cc:dd:ee:ff | true/true | Routed: false | IsPVID: false | | | | | | IPv4 : [] | VID : 3811 | | | | | | IPv6 : [] | | | 13 | enp3 | f2:c7:4b:ac:fd:3e | false/false | Routed: false | IsPVID: true | | | | | | IPv4 : [] | VID : 3813 | | | | | | IPv6 : [] | | | 14 | vlan3813 | aa:bb:cc:dd:ee:ff | true/true | Routed: false | IsPVID: false | | | | | | IPv4 : [] | VID : 3813 | | | | | | IPv6 : [] | | | 15 | enp4 | 12:d2:c3:79:f3:6a | false/false | Routed: false | IsPVID: true | | | | | | IPv4 : [] | VID : 3815 | | | | | | IPv6 : [] | | | 16 | vlan3815 | aa:bb:cc:dd:ee:ff | true/true | Routed: false | IsPVID: false | | | | | | IPv4 : [] | VID : 3815 | | | | | | IPv6 : [] | | | 17 | vlan100 | 56:2e:76:b2:71:48 | false/false | Routed: false | IsPVID: false | | | | | | IPv4 : [] | VID : 100 | | | | | | IPv6 : [] | | Debug loxilb kernel and eBPF components loxilb uses various eBPF maps as part of its DP implementation. These maps are pinned to OS filesystem and can be further used with bpftool to debug. root@0c4f9175c983:/# ls -lart /opt/loxilb/dp/bpf/ total 0 -rw------- 1 root root 0 Jul 10 11:32 xfis -rw------- 1 root root 0 Jul 10 11:32 xfck -rw------- 1 root root 0 Jul 10 11:32 xctk -rw------- 1 root root 0 Jul 10 11:32 tx_intf_stats_map -rw------- 1 root root 0 Jul 10 11:32 tx_intf_map -rw------- 1 root root 0 Jul 10 11:32 tx_bd_stats_map -rw------- 1 root root 0 Jul 10 11:32 tmac_stats_map -rw------- 1 root root 0 Jul 10 11:32 tmac_map -rw------- 1 root root 0 Jul 10 11:32 smac_map -rw------- 1 root root 0 Jul 10 11:32 sess_v4_stats_map -rw------- 1 root root 0 Jul 10 11:32 sess_v4_map -rw------- 1 root root 0 Jul 10 11:32 rt_v6_stats_map -rw------- 1 root root 0 Jul 10 11:32 rt_v4_stats_map -rw------- 1 root root 0 Jul 10 11:32 rt_v4_map -rw------- 1 root root 0 Jul 10 11:32 polx_map -rw------- 1 root root 0 Jul 10 11:32 pkts -rw------- 1 root root 0 Jul 10 11:32 pkt_ring -rw------- 1 root root 0 Jul 10 11:32 pgm_tbl -rw------- 1 root root 0 Jul 10 11:32 nat_v4_map -rw------- 1 root root 0 Jul 10 11:32 mirr_map -rw------- 1 root root 0 Jul 10 11:32 intf_stats_map -rw------- 1 root root 0 Jul 10 11:32 intf_map -rw------- 1 root root 0 Jul 10 11:32 fcas -rw------- 1 root root 0 Jul 10 11:32 fc_v4_stats_map -rw------- 1 root root 0 Jul 10 11:32 fc_v4_map -rw------- 1 root root 0 Jul 10 11:32 dmac_map -rw------- 1 root root 0 Jul 10 11:32 ct_v4_map -rw------- 1 root root 0 Jul 10 11:32 bd_stats_map -rw------- 1 root root 0 Jul 10 11:32 acl_v6_stats_map -rw------- 1 root root 0 Jul 10 11:32 acl_v4_stats_map -rw------- 1 root root 0 Jul 10 11:32 acl_v4_map drwxrwxrwt 3 root root 0 Jul 10 11:32 .. lrwxrwxrwx 1 root root 0 Jul 10 11:32 xdp -> /opt/loxilb/dp/bpf//tc/ drwx------ 3 root root 0 Jul 10 11:32 tc lrwxrwxrwx 1 root root 0 Jul 10 11:32 ip -> /opt/loxilb/dp/bpf//tc/ root@752531364e2c:/# bpftool map dump pinned /opt/loxilb/dp/bpf/intf_map [{ \"key\": { \"ifindex\": 2, \"ing_vid\": 0, \"pad\": 0 }, \"value\": { \"ca\": { \"act_type\": 11, \"ftrap\": 0, \"oif\": 0, \"cidx\": 0 }, \"\": { \"set_ifi\": { \"xdp_ifidx\": 1, \"zone\": 0, \"bd\": 3801, \"mirr\": 0, \"polid\": 0, \"r\": [0,0,0,0,0,0 ] } } } },{ \"key\": { \"ifindex\": 3, \"ing_vid\": 0, \"pad\": 0 }, \"value\": { \"ca\": { \"act_type\": 11, \"ftrap\": 0, \"oif\": 0, \"cidx\": 0 }, \"\": { \"set_ifi\": { \"xdp_ifidx\": 3, \"zone\": 0, \"bd\": 3803, \"mirr\": 0, \"polid\": 0, \"r\": [0,0,0,0,0,0 ] } } } } ] root@752531364e2c:/# bpftool map dump pinned /opt/loxilb/dp/bpf/nat_v4_map [{ \"key\": { \"daddr\": 17435146, \"dport\": 58375, \"zone\": 0, \"l4proto\": 6 }, \"value\": { \"ca\": { \"act_type\": 5, \"ftrap\": 0, \"oif\": 0, \"cidx\": 1 }, \"lock\": { \"val\": 0 }, \"nxfrm\": 3, \"sel_hint\": 0, \"sel_type\": 0, \"nxfrms\": [{ \"nat_flags\": 0, \"inactive\": 0, \"wprio\": 1, \"res\": 0, \"nat_xport\": 35091, \"nat_xip\": 18816799 },{ \"nat_flags\": 0, \"inactive\": 0, \"wprio\": 2, \"res\": 0, \"nat_xport\": 35091, \"nat_xip\": 18882592 },{ \"nat_flags\": 0, \"inactive\": 0, \"wprio\": 2, \"res\": 0, \"nat_xport\": 35091, \"nat_xip\": 23356516 },{ \"nat_flags\": 0, \"inactive\": 1, \"wprio\": 0, \"res\": 0, \"nat_xport\": 0, \"nat_xip\": 0 },{ \"nat_flags\": 0, \"inactive\": 1, \"wprio\": 0, \"res\": 0, \"nat_xport\": 0, \"nat_xip\": 0 },{ \"nat_flags\": 0, \"inactive\": 1, \"wprio\": 0, \"res\": 0, \"nat_xport\": 0, \"nat_xip\": 0 },{ \"nat_flags\": 0, \"inactive\": 1, \"wprio\": 0, \"res\": 0, \"nat_xport\": 0, \"nat_xip\": 0 },{ \"nat_flags\": 0, \"inactive\": 1, \"wprio\": 0, \"res\": 0, \"nat_xport\": 0, \"nat_xip\": 0 },{ \"nat_flags\": 0, \"inactive\": 1, \"wprio\": 0, \"res\": 0, \"nat_xport\": 0, \"nat_xip\": 0 },{ \"nat_flags\": 0, \"inactive\": 1, \"wprio\": 0, \"res\": 0, \"nat_xport\": 0, \"nat_xip\": 0 },{ \"nat_flags\": 0, \"inactive\": 1, \"wprio\": 0, \"res\": 0, \"nat_xport\": 0, \"nat_xip\": 0 },{ \"nat_flags\": 0, \"inactive\": 1, \"wprio\": 0, \"res\": 0, \"nat_xport\": 0, \"nat_xip\": 0 },{ \"nat_flags\": 0, \"inactive\": 1, \"wprio\": 0, \"res\": 0, \"nat_xport\": 0, \"nat_xip\": 0 },{ \"nat_flags\": 0, \"inactive\": 1, \"wprio\": 0, \"res\": 0, \"nat_xport\": 0, \"nat_xip\": 0 },{ \"nat_flags\": 0, \"inactive\": 1, \"wprio\": 0, \"res\": 0, \"nat_xport\": 0, \"nat_xip\": 0 },{ \"nat_flags\": 0, \"inactive\": 1, \"wprio\": 0, \"res\": 0, \"nat_xport\": 0, \"nat_xip\": 0 } ] } } ] Check eBPF kernel debug logs Last but not the least, linux kernel outputs generic eBPF debug logs to /sys/kernel/debug/tracing/trace_pipe. Although loxilb eBPF modules do not emit logs in normal mode of operation, logs can be enabled after a recompilation. root@752531364e2c:/# cat /sys/kernel/debug/tracing/trace_pipe loxicmd-30524 [001] d.s1 27870.170790: bpf_trace_printk: out-dir loxicmd-30524 [001] d.s1 27870.170791: bpf_trace_printk: smr 4 loxicmd-30529 [000] d.s1 27871.617467: bpf_trace_printk: [CTRK] start loxicmd-30529 [000] d.s1 27871.617484: bpf_trace_printk: new-ct4 loxicmd-30529 [000] d.s1 27871.617486: bpf_trace_printk: in-dir loxicmd-30529 [000] d.s1 27871.617488: bpf_trace_printk: smr 0 loxicmd-30529 [000] d.s1 27871.617503: bpf_trace_printk: [CTRK] start loxicmd-30529 [000] d.s1 27871.617503: bpf_trace_printk: out-dir loxicmd-30529 [000] d.s1 27871.617504: bpf_trace_printk: smr 4 sshd-30790 [000] d.s1 27970.031847: bpf_trace_printk: [CTRK] start sshd-30790 [000] d.s1 27970.031866: bpf_trace_printk: new-ct4 sshd-30790 [000] d.s1 27970.031868: bpf_trace_printk: in-dir sshd-30790 [000] d.s1 27970.031870: bpf_trace_printk: smr 0 sshd-30790 [000] d.s1 27970.031887: bpf_trace_printk: [CTRK] start sshd-30790 [000] d.s1 27970.031887: bpf_trace_printk: out-dir sshd-30790 [000] d.s1 27970.031888: bpf_trace_printk: smr 0 sshd-30790 [000] d.s1 27970.031900: bpf_trace_printk: [CTRK] start","title":"loxilb - How to debug"},{"location":"ebpf/","text":"What is eBPF ?? eBPF has been making quite some news lately. An elegant way to extend the linux kernel (or windows) has far reaching implications. Although initially, eBPF was used to enhance system observability beyond existing tools, we will explore in this post how eBPF can be used for enhancing Linux networking performance. There are a lot of additional resources about eBPF in the eBPF project page . A quick recap The hooks that are of particular interest for this discussion are NIC hook (invoked just after packet is received at NIC) and TC hook (invoked just before Linux starts processing packet with its TCP/IP stack). Programs loaded to the former hook are also known as XDP programs and to the latter are called eBPF TC. Although both use eBPF restricted C syntax, there are significant differences between these types. (We will cover it in a separate blog later). For now, we just need to remember that when dealing with container-to-container or container-to-outside communication eBPF-TC makes much more sense since memory allocation (for skb) will happen either way in such scenarios. The performance bottlenecks Coming back to the focus of our discussion which is of course performance, let us step back and take a look at why Linux sucks at networking performance (or rather why it could perform much faster). Linux networking evolved from the days of dial up modem networking when speed was not of utmost importance. Down the lane, code kept accumulating. Although it is extremely feature rich and RFC compliant, it hardly resembles a powerful data-path networking engine. The following figure shows a call-trace of Linux kernel networking stack: The point is it has become incredibly complex over the years. Once features like NAT, VXLAN, conntrack etc come into play, Linux networking stops scaling due to cache degradation, lock contention etc. One problem leads to the another To avoid performance penalties, many user-space frameworks like DPDK have been widely used, which completely skip the linux kernel networking and directly process packets in the user-space. As simple as that may sound, there are some serious drawbacks in using such frameworks e.g need to dedicate cores (can\u2019t multitask), applications written on a specific user-space driver (PMD) might not run on another as it is, apps are also rendered incompatible across different DPDK releases frequently. Finally, there is a need to redo various parts of the TCP/IP stack and the provisioning involved. In short, it leads to a massive and completely unnecessary need of reinventing the wheel. We will have a detailed post later to discuss these factors. But for now, in short, if we are looking to get more out of a box than doing only networking, DPDK is not the right choice. In the age of distributed edge computing and immersive metaverse, the need to do more out of less is of utmost importance. eBPF comes to the rescue Now, eBPF changes all of this. eBPF is hosted inside the kernel so the biggest advantage of eBPF is it can co-exist with Linux/OS without the need of using dedicated cores, skipping the Kernel stack or breaking tools used for ages by the community. Handling of new protocols and functionality can be done in the fly without waiting for kernel development to catch up.","title":"What is eBPF"},{"location":"ebpf/#what-is-ebpf","text":"eBPF has been making quite some news lately. An elegant way to extend the linux kernel (or windows) has far reaching implications. Although initially, eBPF was used to enhance system observability beyond existing tools, we will explore in this post how eBPF can be used for enhancing Linux networking performance. There are a lot of additional resources about eBPF in the eBPF project page .","title":"What is eBPF ??"},{"location":"ebpf/#a-quick-recap","text":"The hooks that are of particular interest for this discussion are NIC hook (invoked just after packet is received at NIC) and TC hook (invoked just before Linux starts processing packet with its TCP/IP stack). Programs loaded to the former hook are also known as XDP programs and to the latter are called eBPF TC. Although both use eBPF restricted C syntax, there are significant differences between these types. (We will cover it in a separate blog later). For now, we just need to remember that when dealing with container-to-container or container-to-outside communication eBPF-TC makes much more sense since memory allocation (for skb) will happen either way in such scenarios.","title":"A quick recap"},{"location":"ebpf/#the-performance-bottlenecks","text":"Coming back to the focus of our discussion which is of course performance, let us step back and take a look at why Linux sucks at networking performance (or rather why it could perform much faster). Linux networking evolved from the days of dial up modem networking when speed was not of utmost importance. Down the lane, code kept accumulating. Although it is extremely feature rich and RFC compliant, it hardly resembles a powerful data-path networking engine. The following figure shows a call-trace of Linux kernel networking stack: The point is it has become incredibly complex over the years. Once features like NAT, VXLAN, conntrack etc come into play, Linux networking stops scaling due to cache degradation, lock contention etc.","title":"The performance bottlenecks"},{"location":"ebpf/#one-problem-leads-to-the-another","text":"To avoid performance penalties, many user-space frameworks like DPDK have been widely used, which completely skip the linux kernel networking and directly process packets in the user-space. As simple as that may sound, there are some serious drawbacks in using such frameworks e.g need to dedicate cores (can\u2019t multitask), applications written on a specific user-space driver (PMD) might not run on another as it is, apps are also rendered incompatible across different DPDK releases frequently. Finally, there is a need to redo various parts of the TCP/IP stack and the provisioning involved. In short, it leads to a massive and completely unnecessary need of reinventing the wheel. We will have a detailed post later to discuss these factors. But for now, in short, if we are looking to get more out of a box than doing only networking, DPDK is not the right choice. In the age of distributed edge computing and immersive metaverse, the need to do more out of less is of utmost importance.","title":"One problem leads to the another"},{"location":"ebpf/#ebpf-comes-to-the-rescue","text":"Now, eBPF changes all of this. eBPF is hosted inside the kernel so the biggest advantage of eBPF is it can co-exist with Linux/OS without the need of using dedicated cores, skipping the Kernel stack or breaking tools used for ages by the community. Handling of new protocols and functionality can be done in the fly without waiting for kernel development to catch up.","title":"eBPF comes to the rescue"},{"location":"faq/","text":"loxilb FAQs Does loxilb depend on what kind of CNI is deployed in the cluster ? Yes, loxilb configuration and operation might be related to which CNI (Calico, Cilium etc) is in use. loxilb just needs a way to find a route to its end-points. This also depends on how the network topology is laid out. For example, if a separated network for nodePort and external LB services is in effect or not. We will have a detailed guide on best practices for loxilb deployment soon. In the meantime, kindly reach out to us via github or loxilb forum Can loxilb be possibly run outside the released docker image ? Yes, loxilb can be run outside the provided docker image. Docker image gives it good portability across various linux like OS's without any performance impact. However, if need is to run outside its own docker, kindly follow README of various loxilb-io repositories. Can loxilb also act as a CNI ? loxilb supports many functionalities of a CNI but loxilb dev team is happy solving external LB and related connectivity problems for the time being. If there is a future requirement not met by currently available CNIs, we might work chip in as well Is there a commercially supported version of loxilb ? At this point of time, loxilb-team is working hard to provide a high-quality open-source product. If users need commercial support, kindly get in touch with us Can loxilb run in a standalone mode (without Kubernetes) ? Very much so. loxilb can run in a standalone mode. Please follow various guides available in loxilb repo to run loxilb in a standalone mode. How loxilb ensures conformance wtih Kubernetes ? loxilb uses kubetest/kubetest2 plus various other test-utilities as part of its CI/CD workflows. We are also planning to get ourselves officially supported by distros like RedHat Openshift Where is loxilb deployed so far ? loxilb is currently used in academia for R&D and various organizations are in process of using it for PoCs. We will update the list of deployments as and when they are officially known","title":"FAQs"},{"location":"faq/#loxilb-faqs","text":"Does loxilb depend on what kind of CNI is deployed in the cluster ? Yes, loxilb configuration and operation might be related to which CNI (Calico, Cilium etc) is in use. loxilb just needs a way to find a route to its end-points. This also depends on how the network topology is laid out. For example, if a separated network for nodePort and external LB services is in effect or not. We will have a detailed guide on best practices for loxilb deployment soon. In the meantime, kindly reach out to us via github or loxilb forum Can loxilb be possibly run outside the released docker image ? Yes, loxilb can be run outside the provided docker image. Docker image gives it good portability across various linux like OS's without any performance impact. However, if need is to run outside its own docker, kindly follow README of various loxilb-io repositories. Can loxilb also act as a CNI ? loxilb supports many functionalities of a CNI but loxilb dev team is happy solving external LB and related connectivity problems for the time being. If there is a future requirement not met by currently available CNIs, we might work chip in as well Is there a commercially supported version of loxilb ? At this point of time, loxilb-team is working hard to provide a high-quality open-source product. If users need commercial support, kindly get in touch with us Can loxilb run in a standalone mode (without Kubernetes) ? Very much so. loxilb can run in a standalone mode. Please follow various guides available in loxilb repo to run loxilb in a standalone mode. How loxilb ensures conformance wtih Kubernetes ? loxilb uses kubetest/kubetest2 plus various other test-utilities as part of its CI/CD workflows. We are also planning to get ourselves officially supported by distros like RedHat Openshift Where is loxilb deployed so far ? loxilb is currently used in academia for R&D and various organizations are in process of using it for PoCs. We will update the list of deployments as and when they are officially known","title":"loxilb FAQs"},{"location":"lb/","text":"What is service type external load-balancer in Kubernetes ? There are many different types of services like NodePort, ClusterIP etc. However, service type external load-balancer provides a way of exposing your application internally and/or externally in the perspective of the k8s cluster. Usually, Kubernetes CCM provider ensures that a load balancer of some sort is created, deleted and updated in your cloud. For on-prem or edge deployments however, organziations need to provide their own CCM load-balancer functions. MetalLB has been the choice for such cases for long. But edge services need to support so many exotic protocols in play like GTP, SCTP, SRv6 etc and integrating everything into a seamlessly working solution has been quite difficult. This is an area where loxilb aims to play a pivotal role. The following is a simple yaml config file which needs to be applied to create a service type load-balancer : \"type\": \"LoadBalancer\" { \"kind\": \"Service\", \"apiVersion\": \"v1\", \"metadata\": { \"name\": \"sample-service\" }, \"spec\": { \"ports\": [{ \"port\": 9001, \"targetPort\": 5001 }], \"selector\": { \"app\": \"sample\" }, \"type\": \"LoadBalancer\" } } However, if there is no K8s CCM plugin implementing external service load-balancer, such services won't be created and remain in pending state forever.","title":"What is service type - external load-balancer"},{"location":"lb/#what-is-service-type-external-load-balancer-in-kubernetes","text":"There are many different types of services like NodePort, ClusterIP etc. However, service type external load-balancer provides a way of exposing your application internally and/or externally in the perspective of the k8s cluster. Usually, Kubernetes CCM provider ensures that a load balancer of some sort is created, deleted and updated in your cloud. For on-prem or edge deployments however, organziations need to provide their own CCM load-balancer functions. MetalLB has been the choice for such cases for long. But edge services need to support so many exotic protocols in play like GTP, SCTP, SRv6 etc and integrating everything into a seamlessly working solution has been quite difficult. This is an area where loxilb aims to play a pivotal role. The following is a simple yaml config file which needs to be applied to create a service type load-balancer : \"type\": \"LoadBalancer\" { \"kind\": \"Service\", \"apiVersion\": \"v1\", \"metadata\": { \"name\": \"sample-service\" }, \"spec\": { \"ports\": [{ \"port\": 9001, \"targetPort\": 5001 }], \"selector\": { \"app\": \"sample\" }, \"type\": \"LoadBalancer\" } } However, if there is no K8s CCM plugin implementing external service load-balancer, such services won't be created and remain in pending state forever.","title":"What is service type external load-balancer in Kubernetes ?"},{"location":"loxilbebpf/","text":"loxilb eBPF implementation details In this section, we will look into details of loxilb ebpf implementation in little details and try to check what goes on under the hood. When loxilb is build, it builds two object files as follows : llb@nd2:~/loxilb$ ls -l /opt/loxilb/ total 396 drwxrwxrwt 3 root root 0 6?? 20 11:17 dp -rw-rw-r-- 1 llb llb 305536 6?? 29 09:39 llb_ebpf_main.o -rw-rw-r-- 1 llb llb 95192 6?? 29 09:39 llb_xdp_main.o As the name suggests and based on hook point, xdp version does XDP packet processing while ebpf version is used at TC layer for TC eBPF processing. Interesting enough, the packet forwarding code is largely agnostic of its final hook point due to usage of a light abstraction layer to hide differences between eBPF and XDP layer. Now this beckons the question why separate hook points and how does it all work together ? loxilb does bulk of its processing at TC eBPF layer as this layer is most optimized for doing L4+ processing needed for loxilb operation. XDP's frame format is different than what is used by skb (linux kernel's generic socket buffer). This makes it very difficult (if not impossible) to do tcp checksum offload and other such features used by linux networking stack for quite some time now. In short, if we need to do such operations, XDP performance will be inherently slow. XDP as such is perfect for quick operations at l2 layer. loxilb uses XDP to do certain operations like mirroring. Due to how TC eBPF works, it is difficult to work with multiple packet copies and loxilb's TC eBPF offloads some functinality to XDP layer in such special cases. Loading of loxilb eBPF program loxilb's goLang based agent by default loads the loxilb ebpf programs in all the interfaces(only physical/real/bond/wireguard) available in the system. As loxilb is designed to run in its own docker/container, this is convenient for users who dont want to have to manually load/unload eBPF programs. However, it is still possible to do so manually if need arises : To load : ntc filter add dev eth1 ingress bpf da obj /opt/loxilb/llb_ebpf_main.o sec tc_packet_parser To unload: ntc filter del dev eth1 ingress To check: root@nd2:/home/llb# ntc filter show dev hs2 ingress filter protocol all pref 49152 bpf chain 0 filter protocol all pref 49152 bpf chain 0 handle 0x1 llb_ebpf_main.o:[tc_packet_parser] direct-action not_in_hw id 8715 tag 43a829222e969bce jited Please not that ntc is the customized tc tool from iproute2 package which can be found in loxilb's repository Entry points of loxilb eBPF loxilb's eBPF code is usually divided into two program sections with the following entry functions : tc_packet_func This alongwith the consequent code does majority of the packet processing. If conntrack entries are in established state, this is also responsible for packet tx. However if conntrack entry for a particular packet flow is not established, it makes a bpf tail call to the tc_packet_func_slow tc_packet_func_slow This is responsible mainly for doing NAT lookup and stateful conntrack implementation. Once conntrack entry transitions to established state, the forwarding then can happen directly from tc_packet_func loxilb's XDP code is contained in the following section : xdp_packet_func This is the entry point for packet processing when hook point is XDP instead of TC eBPF Pinned Maps of loxilb eBPF All maps used by loxilb eBPF are mounted in the file-system as below : root@nd2:/home/llb/loxilb# ls -lart /opt/loxilb/dp/ total 4 drwxrwxrwt 3 root root 0 6?? 20 11:17 . drwxr-xr-x 3 root root 4096 6?? 29 10:19 .. drwx------ 3 root root 0 6?? 29 10:19 bpf root@nd2:/home/llb/loxilb# mount | grep bpf none on /opt/netlox/loxilb type bpf (rw,relatime) root@nd2:/home/llb/loxilb# ls -lart /opt/loxilb/dp/bpf/ total 0 drwxrwxrwt 3 root root 0 6?? 20 11:17 .. lrwxrwxrwx 1 root root 0 6?? 20 11:17 xdp -> /opt/loxilb/dp/bpf//tc/ drwx------ 3 root root 0 6?? 20 11:17 tc lrwxrwxrwx 1 root root 0 6?? 20 11:17 ip -> /opt/loxilb/dp/bpf//tc/ -rw------- 1 root root 0 6?? 29 10:19 xfis -rw------- 1 root root 0 6?? 29 10:19 xfck -rw------- 1 root root 0 6?? 29 10:19 xctk -rw------- 1 root root 0 6?? 29 10:19 tx_intf_stats_map -rw------- 1 root root 0 6?? 29 10:19 tx_intf_map -rw------- 1 root root 0 6?? 29 10:19 tx_bd_stats_map -rw------- 1 root root 0 6?? 29 10:19 tmac_stats_map -rw------- 1 root root 0 6?? 29 10:19 tmac_map -rw------- 1 root root 0 6?? 29 10:19 smac_map -rw------- 1 root root 0 6?? 29 10:19 rt_v6_stats_map -rw------- 1 root root 0 6?? 29 10:19 rt_v4_stats_map -rw------- 1 root root 0 6?? 29 10:19 rt_v4_map -rw------- 1 root root 0 6?? 29 10:19 polx_map -rw------- 1 root root 0 6?? 29 10:19 pkts -rw------- 1 root root 0 6?? 29 10:19 pkt_ring -rw------- 1 root root 0 6?? 29 10:19 pgm_tbl -rw------- 1 root root 0 6?? 29 10:19 nh_map -rw------- 1 root root 0 6?? 29 10:19 nat_v4_map -rw------- 1 root root 0 6?? 29 10:19 mirr_map -rw------- 1 root root 0 6?? 29 10:19 intf_stats_map -rw------- 1 root root 0 6?? 29 10:19 intf_map -rw------- 1 root root 0 6?? 29 10:19 fc_v4_stats_map -rw------- 1 root root 0 6?? 29 10:19 fc_v4_map -rw------- 1 root root 0 6?? 29 10:19 fcas -rw------- 1 root root 0 6?? 29 10:19 dmac_map -rw------- 1 root root 0 6?? 29 10:19 ct_v4_map -rw------- 1 root root 0 6?? 29 10:19 bd_stats_map -rw------- 1 root root 0 6?? 29 10:19 acl_v6_stats_map -rw------- 1 root root 0 6?? 29 10:19 acl_v4_stats_map -rw------- 1 root root 0 6?? 29 10:19 acl_v4_map Using bpftool, it is easy to check state of these maps as follows : root@nd2:/home/llb# bpftool map dump pinned /opt/loxilb/dp/bpf/intf_map [{ \"key\": { \"ifindex\": 2, \"ing_vid\": 0, \"pad\": 0 }, \"value\": { \"ca\": { \"act_type\": 11, \"ftrap\": 0, \"oif\": 0, \"cidx\": 0 }, \"\": { \"set_ifi\": { \"xdp_ifidx\": 1, \"zone\": 0, \"bd\": 3801, \"mirr\": 0, \"polid\": 0, \"r\": [0,0,0,0,0,0 ] } } } },{ \"key\": { \"ifindex\": 3, \"ing_vid\": 0, \"pad\": 0 }, \"value\": { \"ca\": { \"act_type\": 11, \"ftrap\": 0, \"oif\": 0, \"cidx\": 0 }, \"\": { \"set_ifi\": { \"xdp_ifidx\": 3, \"zone\": 0, \"bd\": 3803, \"mirr\": 0, \"polid\": 0, \"r\": [0,0,0,0,0,0 ] } } } } ] As our development progresses, we will keep updating details about these map's internals loxilb eBPF pipeline at a glance The following figure shows a very high-level diagram of packet flow through loxilb eBPF pipeline : We use eBPF tail calls to jump from one section to another majorly due to the fact that there is clear separation for CT (conntrack) functionality and packet-forwarding logic. At the same time, kernel's built in eBPF-verifier imposes a maximum code size limit for a single program.","title":"eBPF internals of loxilb"},{"location":"loxilbebpf/#loxilb-ebpf-implementation-details","text":"In this section, we will look into details of loxilb ebpf implementation in little details and try to check what goes on under the hood. When loxilb is build, it builds two object files as follows : llb@nd2:~/loxilb$ ls -l /opt/loxilb/ total 396 drwxrwxrwt 3 root root 0 6?? 20 11:17 dp -rw-rw-r-- 1 llb llb 305536 6?? 29 09:39 llb_ebpf_main.o -rw-rw-r-- 1 llb llb 95192 6?? 29 09:39 llb_xdp_main.o As the name suggests and based on hook point, xdp version does XDP packet processing while ebpf version is used at TC layer for TC eBPF processing. Interesting enough, the packet forwarding code is largely agnostic of its final hook point due to usage of a light abstraction layer to hide differences between eBPF and XDP layer. Now this beckons the question why separate hook points and how does it all work together ? loxilb does bulk of its processing at TC eBPF layer as this layer is most optimized for doing L4+ processing needed for loxilb operation. XDP's frame format is different than what is used by skb (linux kernel's generic socket buffer). This makes it very difficult (if not impossible) to do tcp checksum offload and other such features used by linux networking stack for quite some time now. In short, if we need to do such operations, XDP performance will be inherently slow. XDP as such is perfect for quick operations at l2 layer. loxilb uses XDP to do certain operations like mirroring. Due to how TC eBPF works, it is difficult to work with multiple packet copies and loxilb's TC eBPF offloads some functinality to XDP layer in such special cases.","title":"loxilb eBPF implementation details"},{"location":"loxilbebpf/#loading-of-loxilb-ebpf-program","text":"loxilb's goLang based agent by default loads the loxilb ebpf programs in all the interfaces(only physical/real/bond/wireguard) available in the system. As loxilb is designed to run in its own docker/container, this is convenient for users who dont want to have to manually load/unload eBPF programs. However, it is still possible to do so manually if need arises : To load : ntc filter add dev eth1 ingress bpf da obj /opt/loxilb/llb_ebpf_main.o sec tc_packet_parser To unload: ntc filter del dev eth1 ingress To check: root@nd2:/home/llb# ntc filter show dev hs2 ingress filter protocol all pref 49152 bpf chain 0 filter protocol all pref 49152 bpf chain 0 handle 0x1 llb_ebpf_main.o:[tc_packet_parser] direct-action not_in_hw id 8715 tag 43a829222e969bce jited Please not that ntc is the customized tc tool from iproute2 package which can be found in loxilb's repository","title":"Loading of loxilb eBPF program"},{"location":"loxilbebpf/#entry-points-of-loxilb-ebpf","text":"loxilb's eBPF code is usually divided into two program sections with the following entry functions : tc_packet_func This alongwith the consequent code does majority of the packet processing. If conntrack entries are in established state, this is also responsible for packet tx. However if conntrack entry for a particular packet flow is not established, it makes a bpf tail call to the tc_packet_func_slow tc_packet_func_slow This is responsible mainly for doing NAT lookup and stateful conntrack implementation. Once conntrack entry transitions to established state, the forwarding then can happen directly from tc_packet_func loxilb's XDP code is contained in the following section : xdp_packet_func This is the entry point for packet processing when hook point is XDP instead of TC eBPF","title":"Entry points of loxilb eBPF"},{"location":"loxilbebpf/#pinned-maps-of-loxilb-ebpf","text":"All maps used by loxilb eBPF are mounted in the file-system as below : root@nd2:/home/llb/loxilb# ls -lart /opt/loxilb/dp/ total 4 drwxrwxrwt 3 root root 0 6?? 20 11:17 . drwxr-xr-x 3 root root 4096 6?? 29 10:19 .. drwx------ 3 root root 0 6?? 29 10:19 bpf root@nd2:/home/llb/loxilb# mount | grep bpf none on /opt/netlox/loxilb type bpf (rw,relatime) root@nd2:/home/llb/loxilb# ls -lart /opt/loxilb/dp/bpf/ total 0 drwxrwxrwt 3 root root 0 6?? 20 11:17 .. lrwxrwxrwx 1 root root 0 6?? 20 11:17 xdp -> /opt/loxilb/dp/bpf//tc/ drwx------ 3 root root 0 6?? 20 11:17 tc lrwxrwxrwx 1 root root 0 6?? 20 11:17 ip -> /opt/loxilb/dp/bpf//tc/ -rw------- 1 root root 0 6?? 29 10:19 xfis -rw------- 1 root root 0 6?? 29 10:19 xfck -rw------- 1 root root 0 6?? 29 10:19 xctk -rw------- 1 root root 0 6?? 29 10:19 tx_intf_stats_map -rw------- 1 root root 0 6?? 29 10:19 tx_intf_map -rw------- 1 root root 0 6?? 29 10:19 tx_bd_stats_map -rw------- 1 root root 0 6?? 29 10:19 tmac_stats_map -rw------- 1 root root 0 6?? 29 10:19 tmac_map -rw------- 1 root root 0 6?? 29 10:19 smac_map -rw------- 1 root root 0 6?? 29 10:19 rt_v6_stats_map -rw------- 1 root root 0 6?? 29 10:19 rt_v4_stats_map -rw------- 1 root root 0 6?? 29 10:19 rt_v4_map -rw------- 1 root root 0 6?? 29 10:19 polx_map -rw------- 1 root root 0 6?? 29 10:19 pkts -rw------- 1 root root 0 6?? 29 10:19 pkt_ring -rw------- 1 root root 0 6?? 29 10:19 pgm_tbl -rw------- 1 root root 0 6?? 29 10:19 nh_map -rw------- 1 root root 0 6?? 29 10:19 nat_v4_map -rw------- 1 root root 0 6?? 29 10:19 mirr_map -rw------- 1 root root 0 6?? 29 10:19 intf_stats_map -rw------- 1 root root 0 6?? 29 10:19 intf_map -rw------- 1 root root 0 6?? 29 10:19 fc_v4_stats_map -rw------- 1 root root 0 6?? 29 10:19 fc_v4_map -rw------- 1 root root 0 6?? 29 10:19 fcas -rw------- 1 root root 0 6?? 29 10:19 dmac_map -rw------- 1 root root 0 6?? 29 10:19 ct_v4_map -rw------- 1 root root 0 6?? 29 10:19 bd_stats_map -rw------- 1 root root 0 6?? 29 10:19 acl_v6_stats_map -rw------- 1 root root 0 6?? 29 10:19 acl_v4_stats_map -rw------- 1 root root 0 6?? 29 10:19 acl_v4_map Using bpftool, it is easy to check state of these maps as follows : root@nd2:/home/llb# bpftool map dump pinned /opt/loxilb/dp/bpf/intf_map [{ \"key\": { \"ifindex\": 2, \"ing_vid\": 0, \"pad\": 0 }, \"value\": { \"ca\": { \"act_type\": 11, \"ftrap\": 0, \"oif\": 0, \"cidx\": 0 }, \"\": { \"set_ifi\": { \"xdp_ifidx\": 1, \"zone\": 0, \"bd\": 3801, \"mirr\": 0, \"polid\": 0, \"r\": [0,0,0,0,0,0 ] } } } },{ \"key\": { \"ifindex\": 3, \"ing_vid\": 0, \"pad\": 0 }, \"value\": { \"ca\": { \"act_type\": 11, \"ftrap\": 0, \"oif\": 0, \"cidx\": 0 }, \"\": { \"set_ifi\": { \"xdp_ifidx\": 3, \"zone\": 0, \"bd\": 3803, \"mirr\": 0, \"polid\": 0, \"r\": [0,0,0,0,0,0 ] } } } } ] As our development progresses, we will keep updating details about these map's internals","title":"Pinned Maps of loxilb eBPF"},{"location":"loxilbebpf/#loxilb-ebpf-pipeline-at-a-glance","text":"The following figure shows a very high-level diagram of packet flow through loxilb eBPF pipeline : We use eBPF tail calls to jump from one section to another majorly due to the fact that there is clear separation for CT (conntrack) functionality and packet-forwarding logic. At the same time, kernel's built in eBPF-verifier imposes a maximum code size limit for a single program.","title":"loxilb eBPF pipeline at a glance"},{"location":"perf/","text":"loxilb Performance Single node performance (simple) loxilb is run as a docker inside a VM. The VM is assigned the following resources : Intel(R) Core(TM) i7-4770HQ CPU @ 2.20GHz - 2 core RAM 4GB All the other hosts are simulated with docker pods inside the same VM. The following command can be used to configure lb for the given topology: # loxicmd create lb 20.20.20.1 --tcp=2020:5001 --endpoints=31.31.31.1:1,32.32.32.1:1,17.17.17.1:1 graph LR; A[100.100.100.1]-->B[loxilb]; B-->C[31.31.31.1]; B-->D[32.32.32.1]; B-->E[17.17.17.1]; A go webserver with an empty response is used for benchmark purposes. The code is as following : import ( \"log\" \"net/http\" ) func main() { http.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) { }) if err := http.ListenAndServe(\":5001\", nil); err != nil { log.Fatal(\"ListenAndServe: \", err) } } The above code is run in each of the load-balancer end-points. We use wrk HTTP benchmarking tool for this test. This is run inside the client \"100.100.100.1\" host. root@loxilb:/home/loxilb # wrk -t8 -c400 -d30s http://20.20.20.1:2020/ Running 30s test @ http://20.20.20.1:2020/ 8 threads and 400 connections Thread Stats Avg Stdev Max +/- Stdev Latency 11.93ms 13.66ms 164.26ms 86.43% Req/Sec 5.82k 0.99k 14.19k 70.55% 1391123 requests in 30.09s, 99.50MB read Requests/sec: 46232.45 Transfer/sec: 3.31MB As a baseline, we compare the numbers with loopback test i.e running wrk in the same host as the webserver root@loxilb:/home/loxilb # wrk -t8 -c400 -d30s http://127.0.0.1:5001/ Running 30s test @ http://127.0.0.1:5001/ 8 threads and 400 connections Thread Stats Avg Stdev Max +/- Stdev Latency 15.20ms 19.81ms 240.03ms 86.30% Req/Sec 5.90k 3.74k 24.39k 74.35% 1410741 requests in 30.08s, 100.90MB read Requests/sec: 46894.07 Transfer/sec: 3.35MB Based on the above tests, loxilb performs at 98% of the baseline numbers in requests/sec and latency actually improves by 20% with loxilb. Multi node performance (real topology) The topology for this test is similar to the above case. However, all the hosts (client and load-balancer end-points) as well as loxilb run in separate dedicated systems. All other configurations remain the same Perf numbers to be updated Comparision with LVS LVS is based on linux kernel networking and is a popular open-source load-balancer. Comparision with LVS will show us how eBPF can improve on linux kernel networking To be done and updated","title":"Performance"},{"location":"perf/#loxilb-performance","text":"","title":"loxilb Performance"},{"location":"perf/#single-node-performance-simple","text":"loxilb is run as a docker inside a VM. The VM is assigned the following resources : Intel(R) Core(TM) i7-4770HQ CPU @ 2.20GHz - 2 core RAM 4GB All the other hosts are simulated with docker pods inside the same VM. The following command can be used to configure lb for the given topology: # loxicmd create lb 20.20.20.1 --tcp=2020:5001 --endpoints=31.31.31.1:1,32.32.32.1:1,17.17.17.1:1 graph LR; A[100.100.100.1]-->B[loxilb]; B-->C[31.31.31.1]; B-->D[32.32.32.1]; B-->E[17.17.17.1]; A go webserver with an empty response is used for benchmark purposes. The code is as following : import ( \"log\" \"net/http\" ) func main() { http.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) { }) if err := http.ListenAndServe(\":5001\", nil); err != nil { log.Fatal(\"ListenAndServe: \", err) } } The above code is run in each of the load-balancer end-points. We use wrk HTTP benchmarking tool for this test. This is run inside the client \"100.100.100.1\" host. root@loxilb:/home/loxilb # wrk -t8 -c400 -d30s http://20.20.20.1:2020/ Running 30s test @ http://20.20.20.1:2020/ 8 threads and 400 connections Thread Stats Avg Stdev Max +/- Stdev Latency 11.93ms 13.66ms 164.26ms 86.43% Req/Sec 5.82k 0.99k 14.19k 70.55% 1391123 requests in 30.09s, 99.50MB read Requests/sec: 46232.45 Transfer/sec: 3.31MB As a baseline, we compare the numbers with loopback test i.e running wrk in the same host as the webserver root@loxilb:/home/loxilb # wrk -t8 -c400 -d30s http://127.0.0.1:5001/ Running 30s test @ http://127.0.0.1:5001/ 8 threads and 400 connections Thread Stats Avg Stdev Max +/- Stdev Latency 15.20ms 19.81ms 240.03ms 86.30% Req/Sec 5.90k 3.74k 24.39k 74.35% 1410741 requests in 30.08s, 100.90MB read Requests/sec: 46894.07 Transfer/sec: 3.35MB Based on the above tests, loxilb performs at 98% of the baseline numbers in requests/sec and latency actually improves by 20% with loxilb.","title":"Single node performance (simple)"},{"location":"perf/#multi-node-performance-real-topology","text":"The topology for this test is similar to the above case. However, all the hosts (client and load-balancer end-points) as well as loxilb run in separate dedicated systems. All other configurations remain the same Perf numbers to be updated","title":"Multi node performance (real topology)"},{"location":"perf/#comparision-with-lvs","text":"LVS is based on linux kernel networking and is a popular open-source load-balancer. Comparision with LVS will show us how eBPF can improve on linux kernel networking To be done and updated","title":"Comparision with LVS"},{"location":"roadmap/","text":"Release Notes 0.0.1 beta (Jul, 2021) Initial release of loxilb Major functions : Two-Arm Load-Balancer (NAT+Routed mode) 16 end-points (arms) support Load-balancer selection policy Round-robin, traffic-hash (fallback to RR if hash fails) Conntrack support in eBPF - TCP/UDP/ICMP profiles GTP with QFI extension support UL/CL classifier support for MEC Extended QoS support (SRTCM/TRTCM) Support for GoBGP Support for Calico CNI Extended visibility and statistics CCM Support : IP allocation policy Kubernetes 1.20 base support Utilities : loxicmd support : Configuration utlity with the look and feel of kubectl loxidump support : Config export and import utility 0.0.2 (Oct, 2022) - Planned Major functions : Enhanced load-balancer support upto 32 end-points Integrated Firewall support Extended conntrack - SCTP support One-ARM LB mode support SRv6 support HA support Grafana based dashboard CCM Support : OpenShift Integration DPU Support : Nvidia BF2 Support (Depends on community/public demand)","title":"Development Roadmap"},{"location":"roadmap/#release-notes","text":"","title":"Release Notes"},{"location":"roadmap/#001-beta-jul-2021","text":"Initial release of loxilb Major functions : Two-Arm Load-Balancer (NAT+Routed mode) 16 end-points (arms) support Load-balancer selection policy Round-robin, traffic-hash (fallback to RR if hash fails) Conntrack support in eBPF - TCP/UDP/ICMP profiles GTP with QFI extension support UL/CL classifier support for MEC Extended QoS support (SRTCM/TRTCM) Support for GoBGP Support for Calico CNI Extended visibility and statistics CCM Support : IP allocation policy Kubernetes 1.20 base support Utilities : loxicmd support : Configuration utlity with the look and feel of kubectl loxidump support : Config export and import utility","title":"0.0.1 beta (Jul, 2021)"},{"location":"roadmap/#002-oct-2022-planned","text":"Major functions : Enhanced load-balancer support upto 32 end-points Integrated Firewall support Extended conntrack - SCTP support One-ARM LB mode support SRv6 support HA support Grafana based dashboard CCM Support : OpenShift Integration DPU Support : Nvidia BF2 Support (Depends on community/public demand)","title":"0.0.2 (Oct, 2022) - Planned"},{"location":"run/","text":"loxilb - How to build/run Right from code (difficult) Build custom iproute2 package git clone https://github.com/loxilb-io/iproute2.git cd iproute2 cd libbpf/src/ mkdir build DESTDIR=build make install cd ../../ export PKG_CONFIG_PATH=$PKG_CONFIG_PATH:`pwd`/libbpf/src/ LIBBPF_FORCE=on LIBBPF_DIR=`pwd`/libbpf/src/build ./configure make sudo cp -f tc/tc /usr/local/sbin/ntc Build and run loxilb git clone https://github.com/loxilb-io/loxilb.git cd loxilb ./ebpf/utils/mkllb_bpffs.sh make cd ebpf/libbpf/src sudo make install cd - sudo ./loxilb From docker (easy) Get the loxilb official docker image docker pull loxilbio/loxilb:beta To run loxilb docker, we can use the following commands : docker run -u root --cap-add SYS_ADMIN --restart unless-stopped --privileged -dit -v /dev/log:/dev/log --name loxilb loxilbio/loxilb:beta To drop in to a shell of loxilb doker : docker exec -it loxilb bash For load-balancing to effectively work in a bare-metal environment, we need multiple interfaces assigned to the docker (external and internal connectivitiy) loxilb docker relies on docker's macvlan driver for achieving this. The following is an example of creating macvlan network and using with loxilb # Create a mac-vlan (on an underlying interface e.g. enp0s3) docker network create -d macvlan -o parent=enp0s3 --subnet 172.30.1.0/24 --gateway 172.30.1.254 --aux-address 'host=172.30.1.193\u2019 llbnet # Run loxilb docker with the created macvlan docker run -u root --cap-add SYS_ADMIN --restart unless-stopped --privileged -dit -v /dev/log:/dev/log --net=llbnet --ip=172.30.1.193 --name loxilb loxilbio/loxilb:beta # If we still want to connect loxilb docker additionally to docker's default network or more macvlan networks docker network connect bridge loxilb Note - While working with macvlan interfaces, the parent/underlying interface should be put in promiscous mode","title":"Howto - build/run"},{"location":"run/#loxilb-how-to-buildrun","text":"","title":"loxilb - How to build/run"},{"location":"run/#right-from-code-difficult","text":"Build custom iproute2 package git clone https://github.com/loxilb-io/iproute2.git cd iproute2 cd libbpf/src/ mkdir build DESTDIR=build make install cd ../../ export PKG_CONFIG_PATH=$PKG_CONFIG_PATH:`pwd`/libbpf/src/ LIBBPF_FORCE=on LIBBPF_DIR=`pwd`/libbpf/src/build ./configure make sudo cp -f tc/tc /usr/local/sbin/ntc Build and run loxilb git clone https://github.com/loxilb-io/loxilb.git cd loxilb ./ebpf/utils/mkllb_bpffs.sh make cd ebpf/libbpf/src sudo make install cd - sudo ./loxilb","title":"Right from code (difficult)"},{"location":"run/#from-docker-easy","text":"Get the loxilb official docker image docker pull loxilbio/loxilb:beta To run loxilb docker, we can use the following commands : docker run -u root --cap-add SYS_ADMIN --restart unless-stopped --privileged -dit -v /dev/log:/dev/log --name loxilb loxilbio/loxilb:beta To drop in to a shell of loxilb doker : docker exec -it loxilb bash For load-balancing to effectively work in a bare-metal environment, we need multiple interfaces assigned to the docker (external and internal connectivitiy) loxilb docker relies on docker's macvlan driver for achieving this. The following is an example of creating macvlan network and using with loxilb # Create a mac-vlan (on an underlying interface e.g. enp0s3) docker network create -d macvlan -o parent=enp0s3 --subnet 172.30.1.0/24 --gateway 172.30.1.254 --aux-address 'host=172.30.1.193\u2019 llbnet # Run loxilb docker with the created macvlan docker run -u root --cap-add SYS_ADMIN --restart unless-stopped --privileged -dit -v /dev/log:/dev/log --net=llbnet --ip=172.30.1.193 --name loxilb loxilbio/loxilb:beta # If we still want to connect loxilb docker additionally to docker's default network or more macvlan networks docker network connect bridge loxilb Note - While working with macvlan interfaces, the parent/underlying interface should be put in promiscous mode","title":"From docker (easy)"}]}